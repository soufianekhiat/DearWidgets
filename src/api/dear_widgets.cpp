#include <dear_widgets.h>

//#include <clipper.hpp>

//#define IMGUI_DEFINE_MATH_OPERATORS
#include <imgui_internal.h>

#include <string>
#include <chrono>
#include <algorithm>

namespace ImWidgets {
	//////////////////////////////////////////////////////////////////////////
	// Data
	//////////////////////////////////////////////////////////////////////////
	static float s_CIE_1931_2deg_min = 360.0f;
	static float s_CIE_1931_2deg_max = 830.0f;
#define s_CIE_1931_2deg_samplesCount 471
	static float s_CIE_1931_2deg_X[] = { 0.000129900000f,0.000145847000f,0.000163802100f,0.000184003700f,0.000206690200f,0.000232100000f,0.000260728000f,0.000293075000f,0.000329388000f,0.000369914000f,0.000414900000f,0.000464158700f,0.000518986000f,0.000581854000f,0.000655234700f,0.000741600000f,0.000845029600f,0.000964526800f,0.001094949000f,0.001231154000f,0.001368000000f,0.001502050000f,0.001642328000f,0.001802382000f,0.001995757000f,0.002236000000f,0.002535385000f,0.002892603000f,0.003300829000f,0.003753236000f,0.004243000000f,0.004762389000f,0.005330048000f,0.005978712000f,0.006741117000f,0.007650000000f,0.008751373000f,0.010028880000f,0.011421700000f,0.012869010000f,0.014310000000f,0.015704430000f,0.017147440000f,0.018781220000f,0.020748010000f,0.023190000000f,0.026207360000f,0.029782480000f,0.033880920000f,0.038468240000f,0.043510000000f,0.048995600000f,0.055022600000f,0.061718800000f,0.069212000000f,0.077630000000f,0.086958110000f,0.097176720000f,0.108406300000f,0.120767200000f,0.134380000000f,0.149358200000f,0.165395700000f,0.181983100000f,0.198611000000f,0.214770000000f,0.230186800000f,0.244879700000f,0.258777300000f,0.271807900000f,0.283900000000f,0.294943800000f,0.304896500000f,0.313787300000f,0.321645400000f,0.328500000000f,0.334351300000f,0.339210100000f,0.343121300000f,0.346129600000f,0.348280000000f,0.349599900000f,0.350147400000f,0.350013000000f,0.349287000000f,0.348060000000f,0.346373300000f,0.344262400000f,0.341808800000f,0.339094100000f,0.336200000000f,0.333197700000f,0.330041100000f,0.326635700000f,0.322886800000f,0.318700000000f,0.314025100000f,0.308884000000f,0.303290400000f,0.297257900000f,0.290800000000f,0.283970100000f,0.276721400000f,0.268917800000f,0.260422700000f,0.251100000000f,0.240847500000f,0.229851200000f,0.218407200000f,0.206811500000f,0.195360000000f,0.184213600000f,0.173327300000f,0.162688100000f,0.152283300000f,0.142100000000f,0.132178600000f,0.122569600000f,0.113275200000f,0.104297900000f,0.095640000000f,0.087299550000f,0.079308040000f,0.071717760000f,0.064580990000f,0.057950010000f,0.051862110000f,0.046281520000f,0.041150880000f,0.036412830000f,0.032010000000f,0.027917200000f,0.024144400000f,0.020687000000f,0.017540400000f,0.014700000000f,0.012161790000f,0.009919960000f,0.007967240000f,0.006296346000f,0.004900000000f,0.003777173000f,0.002945320000f,0.002424880000f,0.002236293000f,0.002400000000f,0.002925520000f,0.003836560000f,0.005174840000f,0.006982080000f,0.009300000000f,0.012149490000f,0.015535880000f,0.019477520000f,0.023992770000f,0.029100000000f,0.034814850000f,0.041120160000f,0.047985040000f,0.055378610000f,0.063270000000f,0.071635010000f,0.080462240000f,0.089739960000f,0.099456450000f,0.109600000000f,0.120167400000f,0.131114500000f,0.142367900000f,0.153854200000f,0.165500000000f,0.177257100000f,0.189140000000f,0.201169400000f,0.213365800000f,0.225749900000f,0.238320900000f,0.251066800000f,0.263992200000f,0.277101700000f,0.290400000000f,0.303891200000f,0.317572600000f,0.331438400000f,0.345482800000f,0.359700000000f,0.374083900000f,0.388639600000f,0.403378400000f,0.418311500000f,0.433449900000f,0.448795300000f,0.464336000000f,0.480064000000f,0.495971300000f,0.512050100000f,0.528295900000f,0.544691600000f,0.561209400000f,0.577821500000f,0.594500000000f,0.611220900000f,0.627975800000f,0.644760200000f,0.661569700000f,0.678400000000f,0.695239200000f,0.712058600000f,0.728828400000f,0.745518800000f,0.762100000000f,0.778543200000f,0.794825600000f,0.810926400000f,0.826824800000f,0.842500000000f,0.857932500000f,0.873081600000f,0.887894400000f,0.902318100000f,0.916300000000f,0.929799500000f,0.942798400000f,0.955277600000f,0.967217900000f,0.978600000000f,0.989385600000f,0.999548800000f,1.009089200000f,1.018006400000f,1.026300000000f,1.033982700000f,1.040986000000f,1.047188000000f,1.052466700000f,1.056700000000f,1.059794400000f,1.061799200000f,1.062806800000f,1.062909600000f,1.062200000000f,1.060735200000f,1.058443600000f,1.055224400000f,1.050976800000f,1.045600000000f,1.039036900000f,1.031360800000f,1.022666200000f,1.013047700000f,1.002600000000f,0.991367500000f,0.979331400000f,0.966491600000f,0.952847900000f,0.938400000000f,0.923194000000f,0.907244000000f,0.890502000000f,0.872920000000f,0.854449900000f,0.835084000000f,0.814946000000f,0.794186000000f,0.772954000000f,0.751400000000f,0.729583600000f,0.707588800000f,0.685602200000f,0.663810400000f,0.642400000000f,0.621514900000f,0.601113800000f,0.581105200000f,0.561397700000f,0.541900000000f,0.522599500000f,0.503546400000f,0.484743600000f,0.466193900000f,0.447900000000f,0.429861300000f,0.412098000000f,0.394644000000f,0.377533300000f,0.360800000000f,0.344456300000f,0.328516800000f,0.313019200000f,0.298001100000f,0.283500000000f,0.269544800000f,0.256118400000f,0.243189600000f,0.230727200000f,0.218700000000f,0.207097100000f,0.195923200000f,0.185170800000f,0.174832300000f,0.164900000000f,0.155366700000f,0.146230000000f,0.137490000000f,0.129146700000f,0.121200000000f,0.113639700000f,0.106465000000f,0.099690440000f,0.093330610000f,0.087400000000f,0.081900960000f,0.076804280000f,0.072077120000f,0.067686640000f,0.063600000000f,0.059806850000f,0.056282160000f,0.052971040000f,0.049818610000f,0.046770000000f,0.043784050000f,0.040875360000f,0.038072640000f,0.035404610000f,0.032900000000f,0.030564190000f,0.028380560000f,0.026344840000f,0.024452750000f,0.022700000000f,0.021084290000f,0.019599880000f,0.018237320000f,0.016987170000f,0.015840000000f,0.014790640000f,0.013831320000f,0.012948680000f,0.012129200000f,0.011359160000f,0.010629350000f,0.009938846000f,0.009288422000f,0.008678854000f,0.008110916000f,0.007582388000f,0.007088746000f,0.006627313000f,0.006195408000f,0.005790346000f,0.005409826000f,0.005052583000f,0.004717512000f,0.004403507000f,0.004109457000f,0.003833913000f,0.003575748000f,0.003334342000f,0.003109075000f,0.002899327000f,0.002704348000f,0.002523020000f,0.002354168000f,0.002196616000f,0.002049190000f,0.001910960000f,0.001781438000f,0.001660110000f,0.001546459000f,0.001439971000f,0.001340042000f,0.001246275000f,0.001158471000f,0.001076430000f,0.000999949300f,0.000928735800f,0.000862433200f,0.000800750300f,0.000743396000f,0.000690078600f,0.000640515600f,0.000594502100f,0.000551864600f,0.000512429000f,0.000476021300f,0.000442453600f,0.000411511700f,0.000382981400f,0.000356649100f,0.000332301100f,0.000309758600f,0.000288887100f,0.000269539400f,0.000251568200f,0.000234826100f,0.000219171000f,0.000204525800f,0.000190840500f,0.000178065400f,0.000166150500f,0.000155023600f,0.000144621900f,0.000134909800f,0.000125852000f,0.000117413000f,0.000109551500f,0.000102224500f,0.000095394450f,0.000089023900f,0.000083075270f,0.000077512690f,0.000072313040f,0.000067457780f,0.000062928440f,0.000058706520f,0.000054770280f,0.000051099180f,0.000047676540f,0.000044485670f,0.000041509940f,0.000038733240f,0.000036142030f,0.000033723520f,0.000031464870f,0.000029353260f,0.000027375730f,0.000025524330f,0.000023793760f,0.000022178700f,0.000020673830f,0.000019272260f,0.000017966400f,0.000016749910f,0.000015616480f,0.000014559770f,0.000013573870f,0.000012654360f,0.000011797230f,0.000010998440f,0.000010253980f,0.000009559646f,0.000008912044f,0.000008308358f,0.000007745769f,0.000007221456f,0.000006732475f,0.000006276423f,0.000005851304f,0.000005455118f,0.000005085868f,0.000004741466f,0.000004420236f,0.000004120783f,0.000003841716f,0.000003581652f,0.000003339127f,0.000003112949f,0.000002902121f,0.000002705645f,0.000002522525f,0.000002351726f,0.000002192415f,0.000002043902f,0.000001905497f,0.000001776509f,0.000001656215f,0.000001544022f,0.000001439440f,0.000001341977f,0.000001251141f };
	static float s_CIE_1931_2deg_Y[] = { 0.000003917000f,0.000004393581f,0.000004929604f,0.000005532136f,0.000006208245f,0.000006965000f,0.000007813219f,0.000008767336f,0.000009839844f,0.000011043230f,0.000012390000f,0.000013886410f,0.000015557280f,0.000017442960f,0.000019583750f,0.000022020000f,0.000024839650f,0.000028041260f,0.000031531040f,0.000035215210f,0.000039000000f,0.000042826400f,0.000046914600f,0.000051589600f,0.000057176400f,0.000064000000f,0.000072344210f,0.000082212240f,0.000093508160f,0.000106136100f,0.000120000000f,0.000134984000f,0.000151492000f,0.000170208000f,0.000191816000f,0.000217000000f,0.000246906700f,0.000281240000f,0.000318520000f,0.000357266700f,0.000396000000f,0.000433714700f,0.000473024000f,0.000517876000f,0.000572218700f,0.000640000000f,0.000724560000f,0.000825500000f,0.000941160000f,0.001069880000f,0.001210000000f,0.001362091000f,0.001530752000f,0.001720368000f,0.001935323000f,0.002180000000f,0.002454800000f,0.002764000000f,0.003117800000f,0.003526400000f,0.004000000000f,0.004546240000f,0.005159320000f,0.005829280000f,0.006546160000f,0.007300000000f,0.008086507000f,0.008908720000f,0.009767680000f,0.010664430000f,0.011600000000f,0.012573170000f,0.013582720000f,0.014629680000f,0.015715090000f,0.016840000000f,0.018007360000f,0.019214480000f,0.020453920000f,0.021718240000f,0.023000000000f,0.024294610000f,0.025610240000f,0.026958570000f,0.028351250000f,0.029800000000f,0.031310830000f,0.032883680000f,0.034521120000f,0.036225710000f,0.038000000000f,0.039846670000f,0.041768000000f,0.043766000000f,0.045842670000f,0.048000000000f,0.050243680000f,0.052573040000f,0.054980560000f,0.057458720000f,0.060000000000f,0.062601970000f,0.065277520000f,0.068042080000f,0.070911090000f,0.073900000000f,0.077016000000f,0.080266400000f,0.083666800000f,0.087232800000f,0.090980000000f,0.094917550000f,0.099045840000f,0.103367400000f,0.107884600000f,0.112600000000f,0.117532000000f,0.122674400000f,0.127992800000f,0.133452800000f,0.139020000000f,0.144676400000f,0.150469300000f,0.156461900000f,0.162717700000f,0.169300000000f,0.176243100000f,0.183558100000f,0.191273500000f,0.199418000000f,0.208020000000f,0.217119900000f,0.226734500000f,0.236857100000f,0.247481200000f,0.258600000000f,0.270184900000f,0.282293900000f,0.295050500000f,0.308578000000f,0.323000000000f,0.338402100000f,0.354685800000f,0.371698600000f,0.389287500000f,0.407300000000f,0.425629900000f,0.444309600000f,0.463394400000f,0.482939500000f,0.503000000000f,0.523569300000f,0.544512000000f,0.565690000000f,0.586965300000f,0.608200000000f,0.629345600000f,0.650306800000f,0.670875200000f,0.690842400000f,0.710000000000f,0.728185200000f,0.745463600000f,0.761969400000f,0.777836800000f,0.793200000000f,0.808110400000f,0.822496200000f,0.836306800000f,0.849491600000f,0.862000000000f,0.873810800000f,0.884962400000f,0.895493600000f,0.905443200000f,0.914850100000f,0.923734800000f,0.932092400000f,0.939922600000f,0.947225200000f,0.954000000000f,0.960256100000f,0.966007400000f,0.971260600000f,0.976022500000f,0.980300000000f,0.984092400000f,0.987418200000f,0.990312800000f,0.992811600000f,0.994950100000f,0.996710800000f,0.998098300000f,0.999112000000f,0.999748200000f,1.000000000000f,0.999856700000f,0.999304600000f,0.998325500000f,0.996898700000f,0.995000000000f,0.992600500000f,0.989742600000f,0.986444400000f,0.982724100000f,0.978600000000f,0.974083700000f,0.969171200000f,0.963856800000f,0.958134900000f,0.952000000000f,0.945450400000f,0.938499200000f,0.931162800000f,0.923457600000f,0.915400000000f,0.907006400000f,0.898277200000f,0.889204800000f,0.879781600000f,0.870000000000f,0.859861300000f,0.849392000000f,0.838622000000f,0.827581300000f,0.816300000000f,0.804794700000f,0.793082000000f,0.781192000000f,0.769154700000f,0.757000000000f,0.744754100000f,0.732422400000f,0.720003600000f,0.707496500000f,0.694900000000f,0.682219200000f,0.669471600000f,0.656674400000f,0.643844800000f,0.631000000000f,0.618155500000f,0.605314400000f,0.592475600000f,0.579637900000f,0.566800000000f,0.553961100000f,0.541137200000f,0.528352800000f,0.515632300000f,0.503000000000f,0.490468800000f,0.478030400000f,0.465677600000f,0.453403200000f,0.441200000000f,0.429080000000f,0.417036000000f,0.405032000000f,0.393032000000f,0.381000000000f,0.368918400000f,0.356827200000f,0.344776800000f,0.332817600000f,0.321000000000f,0.309338100000f,0.297850400000f,0.286593600000f,0.275624500000f,0.265000000000f,0.254763200000f,0.244889600000f,0.235334400000f,0.226052800000f,0.217000000000f,0.208161600000f,0.199548800000f,0.191155200000f,0.182974400000f,0.175000000000f,0.167223500000f,0.159646400000f,0.152277600000f,0.145125900000f,0.138200000000f,0.131500300000f,0.125024800000f,0.118779200000f,0.112769100000f,0.107000000000f,0.101476200000f,0.096188640000f,0.091122960000f,0.086264850000f,0.081600000000f,0.077120640000f,0.072825520000f,0.068710080000f,0.064769760000f,0.061000000000f,0.057396210000f,0.053955040000f,0.050673760000f,0.047549650000f,0.044580000000f,0.041758720000f,0.039084960000f,0.036563840000f,0.034200480000f,0.032000000000f,0.029962610000f,0.028076640000f,0.026329360000f,0.024708050000f,0.023200000000f,0.021800770000f,0.020501120000f,0.019281080000f,0.018120690000f,0.017000000000f,0.015903790000f,0.014837180000f,0.013810680000f,0.012834780000f,0.011920000000f,0.011068310000f,0.010273390000f,0.009533311000f,0.008846157000f,0.008210000000f,0.007623781000f,0.007085424000f,0.006591476000f,0.006138485000f,0.005723000000f,0.005343059000f,0.004995796000f,0.004676404000f,0.004380075000f,0.004102000000f,0.003838453000f,0.003589099000f,0.003354219000f,0.003134093000f,0.002929000000f,0.002738139000f,0.002559876000f,0.002393244000f,0.002237275000f,0.002091000000f,0.001953587000f,0.001824580000f,0.001703580000f,0.001590187000f,0.001484000000f,0.001384496000f,0.001291268000f,0.001204092000f,0.001122744000f,0.001047000000f,0.000976589600f,0.000911108800f,0.000850133200f,0.000793238400f,0.000740000000f,0.000690082700f,0.000643310000f,0.000599496000f,0.000558454700f,0.000520000000f,0.000483913600f,0.000450052800f,0.000418345200f,0.000388718400f,0.000361100000f,0.000335383500f,0.000311440400f,0.000289165600f,0.000268453900f,0.000249200000f,0.000231301900f,0.000214685600f,0.000199288400f,0.000185047500f,0.000171900000f,0.000159778100f,0.000148604400f,0.000138301600f,0.000128792500f,0.000120000000f,0.000111859500f,0.000104322400f,0.000097335600f,0.000090845870f,0.000084800000f,0.000079146670f,0.000073858000f,0.000068916000f,0.000064302670f,0.000060000000f,0.000055981870f,0.000052225600f,0.000048718400f,0.000045447470f,0.000042400000f,0.000039561040f,0.000036915120f,0.000034448680f,0.000032148160f,0.000030000000f,0.000027991250f,0.000026113560f,0.000024360240f,0.000022724610f,0.000021200000f,0.000019778550f,0.000018452850f,0.000017216870f,0.000016064590f,0.000014990000f,0.000013987280f,0.000013051550f,0.000012178180f,0.000011362540f,0.000010600000f,0.000009885877f,0.000009217304f,0.000008592362f,0.000008009133f,0.000007465700f,0.000006959567f,0.000006487995f,0.000006048699f,0.000005639396f,0.000005257800f,0.000004901771f,0.000004569720f,0.000004260194f,0.000003971739f,0.000003702900f,0.000003452163f,0.000003218302f,0.000003000300f,0.000002797139f,0.000002607800f,0.000002431220f,0.000002266531f,0.000002113013f,0.000001969943f,0.000001836600f,0.000001712230f,0.000001596228f,0.000001488090f,0.000001387314f,0.000001293400f,0.000001205820f,0.000001124143f,0.000001048009f,0.000000977058f,0.000000910930f,0.000000849251f,0.000000791721f,0.000000738090f,0.000000688110f,0.000000641530f,0.000000598090f,0.000000557575f,0.000000519808f,0.000000484612f,0.000000451810f };
	static float s_CIE_1931_2deg_Z[] = { 0.000606100000f,0.000680879200f,0.000765145600f,0.000860012400f,0.000966592800f,0.001086000000f,0.001220586000f,0.001372729000f,0.001543579000f,0.001734286000f,0.001946000000f,0.002177777000f,0.002435809000f,0.002731953000f,0.003078064000f,0.003486000000f,0.003975227000f,0.004540880000f,0.005158320000f,0.005802907000f,0.006450001000f,0.007083216000f,0.007745488000f,0.008501152000f,0.009414544000f,0.010549990000f,0.011965800000f,0.013655870000f,0.015588050000f,0.017730150000f,0.020050010000f,0.022511360000f,0.025202880000f,0.028279720000f,0.031897040000f,0.036210000000f,0.041437710000f,0.047503720000f,0.054119880000f,0.060998030000f,0.067850010000f,0.074486320000f,0.081361560000f,0.089153640000f,0.098540480000f,0.110200000000f,0.124613300000f,0.141701700000f,0.161303500000f,0.183256800000f,0.207400000000f,0.233692100000f,0.262611400000f,0.294774600000f,0.330798500000f,0.371300000000f,0.416209100000f,0.465464200000f,0.519694800000f,0.579530300000f,0.645600000000f,0.718483800000f,0.796713300000f,0.877845900000f,0.959439000000f,1.039050100000f,1.115367300000f,1.188497100000f,1.258123300000f,1.323929600000f,1.385600000000f,1.442635200000f,1.494803500000f,1.542190300000f,1.584880700000f,1.622960000000f,1.656404800000f,1.685295900000f,1.709874500000f,1.730382100000f,1.747060000000f,1.760044600000f,1.769623300000f,1.776263700000f,1.780433400000f,1.782600000000f,1.782968200000f,1.781699800000f,1.779198200000f,1.775867100000f,1.772110000000f,1.768258900000f,1.764039000000f,1.758943800000f,1.752466300000f,1.744100000000f,1.733559500000f,1.720858100000f,1.705936900000f,1.688737200000f,1.669200000000f,1.647528700000f,1.623412700000f,1.596022300000f,1.564528000000f,1.528100000000f,1.486111400000f,1.439521500000f,1.389879900000f,1.338736200000f,1.287640000000f,1.237422300000f,1.187824300000f,1.138761100000f,1.090148000000f,1.041900000000f,0.994197600000f,0.947347300000f,0.901453100000f,0.856619300000f,0.812950100000f,0.770517300000f,0.729444800000f,0.689913600000f,0.652104900000f,0.616200000000f,0.582328600000f,0.550416200000f,0.520337600000f,0.491967300000f,0.465180000000f,0.439924600000f,0.416183600000f,0.393882200000f,0.372945900000f,0.353300000000f,0.334857800000f,0.317552100000f,0.301337500000f,0.286168600000f,0.272000000000f,0.258817100000f,0.246483800000f,0.234771800000f,0.223453300000f,0.212300000000f,0.201169200000f,0.190119600000f,0.179225400000f,0.168560800000f,0.158200000000f,0.148138300000f,0.138375800000f,0.128994200000f,0.120075100000f,0.111700000000f,0.103904800000f,0.096667480000f,0.089982720000f,0.083845310000f,0.078249990000f,0.073208990000f,0.068678160000f,0.064567840000f,0.060788350000f,0.057250010000f,0.053904350000f,0.050746640000f,0.047752760000f,0.044898590000f,0.042160000000f,0.039507280000f,0.036935640000f,0.034458360000f,0.032088720000f,0.029840000000f,0.027711810000f,0.025694440000f,0.023787160000f,0.021989250000f,0.020300000000f,0.018718050000f,0.017240360000f,0.015863640000f,0.014584610000f,0.013400000000f,0.012307230000f,0.011301880000f,0.010377920000f,0.009529306000f,0.008749999000f,0.008035200000f,0.007381600000f,0.006785400000f,0.006242800000f,0.005749999000f,0.005303600000f,0.004899800000f,0.004534200000f,0.004202400000f,0.003900000000f,0.003623200000f,0.003370600000f,0.003141400000f,0.002934800000f,0.002749999000f,0.002585200000f,0.002438600000f,0.002309400000f,0.002196800000f,0.002100000000f,0.002017733000f,0.001948200000f,0.001889800000f,0.001840933000f,0.001800000000f,0.001766267000f,0.001737800000f,0.001711200000f,0.001683067000f,0.001650001000f,0.001610133000f,0.001564400000f,0.001513600000f,0.001458533000f,0.001400000000f,0.001336667000f,0.001270000000f,0.001205000000f,0.001146667000f,0.001100000000f,0.001068800000f,0.001049400000f,0.001035600000f,0.001021200000f,0.001000000000f,0.000968640000f,0.000929920000f,0.000886880000f,0.000842560000f,0.000800000000f,0.000760960000f,0.000723680000f,0.000685920000f,0.000645440000f,0.000600000000f,0.000547866700f,0.000491600000f,0.000435400000f,0.000383466700f,0.000340000000f,0.000307253300f,0.000283160000f,0.000265440000f,0.000251813300f,0.000240000000f,0.000229546700f,0.000220640000f,0.000211960000f,0.000202186700f,0.000190000000f,0.000174213300f,0.000155640000f,0.000135960000f,0.000116853300f,0.000100000000f,0.000086133330f,0.000074600000f,0.000065000000f,0.000056933330f,0.000049999990f,0.000044160000f,0.000039480000f,0.000035720000f,0.000032640000f,0.000030000000f,0.000027653330f,0.000025560000f,0.000023640000f,0.000021813330f,0.000020000000f,0.000018133330f,0.000016200000f,0.000014200000f,0.000012133330f,0.000010000000f,0.000007733333f,0.000005400000f,0.000003200000f,0.000001333333f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f };

	static float s_CIE_1964_10deg_min = 360.0f;
	static float s_CIE_1964_10deg_max = 830.0f;
#define s_CIE_1964_10deg_samplesCount 471
	static float s_CIE_1964_10deg_X[] = { 0.000000122200f,0.000000185138f,0.000000278830f,0.000000417470f,0.000000621330f,0.000000919270f,0.000001351980f,0.000001976540f,0.000002872500f,0.000004149500f,0.000005958600f,0.000008505600f,0.000012068600f,0.000017022600f,0.000023868000f,0.000033266000f,0.000046087000f,0.000063472000f,0.000086892000f,0.000118246000f,0.000159952000f,0.000215080000f,0.000287490000f,0.000381990000f,0.000504550000f,0.000662440000f,0.000864500000f,0.001121500000f,0.001446160000f,0.001853590000f,0.002361600000f,0.002990600000f,0.003764500000f,0.004710200000f,0.005858100000f,0.007242300000f,0.008899600000f,0.010870900000f,0.013198900000f,0.015929200000f,0.019109700000f,0.022788000000f,0.027011000000f,0.031829000000f,0.037278000000f,0.043400000000f,0.050223000000f,0.057764000000f,0.066038000000f,0.075033000000f,0.084736000000f,0.095041000000f,0.105836000000f,0.117066000000f,0.128682000000f,0.140638000000f,0.152893000000f,0.165416000000f,0.178191000000f,0.191214000000f,0.204492000000f,0.217650000000f,0.230267000000f,0.242311000000f,0.253793000000f,0.264737000000f,0.275195000000f,0.285301000000f,0.295143000000f,0.304869000000f,0.314679000000f,0.324355000000f,0.333570000000f,0.342243000000f,0.350312000000f,0.357719000000f,0.364482000000f,0.370493000000f,0.375727000000f,0.380158000000f,0.383734000000f,0.386327000000f,0.387858000000f,0.388396000000f,0.387978000000f,0.386726000000f,0.384696000000f,0.382006000000f,0.378709000000f,0.374915000000f,0.370702000000f,0.366089000000f,0.361045000000f,0.355518000000f,0.349486000000f,0.342957000000f,0.335893000000f,0.328284000000f,0.320150000000f,0.311475000000f,0.302273000000f,0.292858000000f,0.283502000000f,0.274044000000f,0.264263000000f,0.254085000000f,0.243392000000f,0.232187000000f,0.220488000000f,0.208198000000f,0.195618000000f,0.183034000000f,0.170222000000f,0.157348000000f,0.144650000000f,0.132349000000f,0.120584000000f,0.109456000000f,0.099042000000f,0.089388000000f,0.080507000000f,0.072034000000f,0.063710000000f,0.055694000000f,0.048117000000f,0.041072000000f,0.034642000000f,0.028896000000f,0.023876000000f,0.019628000000f,0.016172000000f,0.013300000000f,0.010759000000f,0.008542000000f,0.006661000000f,0.005132000000f,0.003982000000f,0.003239000000f,0.002934000000f,0.003114000000f,0.003816000000f,0.005095000000f,0.006936000000f,0.009299000000f,0.012147000000f,0.015444000000f,0.019156000000f,0.023250000000f,0.027690000000f,0.032444000000f,0.037465000000f,0.042956000000f,0.049114000000f,0.055920000000f,0.063349000000f,0.071358000000f,0.079901000000f,0.088909000000f,0.098293000000f,0.107949000000f,0.117749000000f,0.127839000000f,0.138450000000f,0.149516000000f,0.161041000000f,0.172953000000f,0.185209000000f,0.197755000000f,0.210538000000f,0.223460000000f,0.236491000000f,0.249633000000f,0.262972000000f,0.276515000000f,0.290269000000f,0.304213000000f,0.318361000000f,0.332705000000f,0.347232000000f,0.361926000000f,0.376772000000f,0.391683000000f,0.406594000000f,0.421539000000f,0.436517000000f,0.451584000000f,0.466782000000f,0.482147000000f,0.497738000000f,0.513606000000f,0.529826000000f,0.546440000000f,0.563426000000f,0.580726000000f,0.598290000000f,0.616053000000f,0.633948000000f,0.651901000000f,0.669824000000f,0.687632000000f,0.705224000000f,0.722773000000f,0.740483000000f,0.758273000000f,0.776083000000f,0.793832000000f,0.811436000000f,0.828822000000f,0.845879000000f,0.862525000000f,0.878655000000f,0.894208000000f,0.909206000000f,0.923672000000f,0.937638000000f,0.951162000000f,0.964283000000f,0.977068000000f,0.989590000000f,1.001910000000f,1.014160000000f,1.026500000000f,1.038800000000f,1.051000000000f,1.062900000000f,1.074300000000f,1.085200000000f,1.095200000000f,1.104200000000f,1.112000000000f,1.118520000000f,1.123800000000f,1.128000000000f,1.131100000000f,1.133200000000f,1.134300000000f,1.134300000000f,1.133300000000f,1.131200000000f,1.128100000000f,1.123990000000f,1.118900000000f,1.112900000000f,1.105900000000f,1.098000000000f,1.089100000000f,1.079200000000f,1.068400000000f,1.056700000000f,1.044000000000f,1.030480000000f,1.016000000000f,1.000800000000f,0.984790000000f,0.968080000000f,0.950740000000f,0.932800000000f,0.914340000000f,0.895390000000f,0.876030000000f,0.856297000000f,0.836350000000f,0.816290000000f,0.796050000000f,0.775610000000f,0.754930000000f,0.733990000000f,0.712780000000f,0.691290000000f,0.669520000000f,0.647467000000f,0.625110000000f,0.602520000000f,0.579890000000f,0.557370000000f,0.535110000000f,0.513240000000f,0.491860000000f,0.471080000000f,0.450960000000f,0.431567000000f,0.412870000000f,0.394750000000f,0.377210000000f,0.360190000000f,0.343690000000f,0.327690000000f,0.312170000000f,0.297110000000f,0.282500000000f,0.268329000000f,0.254590000000f,0.241300000000f,0.228480000000f,0.216140000000f,0.204300000000f,0.192950000000f,0.182110000000f,0.171770000000f,0.161920000000f,0.152568000000f,0.143670000000f,0.135200000000f,0.127130000000f,0.119480000000f,0.112210000000f,0.105310000000f,0.098786000000f,0.092610000000f,0.086773000000f,0.081260600000f,0.076048000000f,0.071114000000f,0.066454000000f,0.062062000000f,0.057930000000f,0.054050000000f,0.050412000000f,0.047006000000f,0.043823000000f,0.040850800000f,0.038072000000f,0.035468000000f,0.033031000000f,0.030753000000f,0.028623000000f,0.026635000000f,0.024781000000f,0.023052000000f,0.021441000000f,0.019941300000f,0.018544000000f,0.017241000000f,0.016027000000f,0.014896000000f,0.013842000000f,0.012862000000f,0.011949000000f,0.011100000000f,0.010311000000f,0.009576880000f,0.008894000000f,0.008258100000f,0.007666400000f,0.007116300000f,0.006605200000f,0.006130600000f,0.005690300000f,0.005281900000f,0.004903300000f,0.004552630000f,0.004227500000f,0.003925800000f,0.003645700000f,0.003385900000f,0.003144700000f,0.002920800000f,0.002713000000f,0.002520200000f,0.002341100000f,0.002174960000f,0.002020600000f,0.001877300000f,0.001744100000f,0.001620500000f,0.001505700000f,0.001399200000f,0.001300400000f,0.001208700000f,0.001123600000f,0.001044760000f,0.000971560000f,0.000903600000f,0.000840480000f,0.000781870000f,0.000727450000f,0.000676900000f,0.000629960000f,0.000586370000f,0.000545870000f,0.000508258000f,0.000473300000f,0.000440800000f,0.000410580000f,0.000382490000f,0.000356380000f,0.000332110000f,0.000309550000f,0.000288580000f,0.000269090000f,0.000250969000f,0.000234130000f,0.000218470000f,0.000203910000f,0.000190350000f,0.000177730000f,0.000165970000f,0.000155020000f,0.000144800000f,0.000135280000f,0.000126390000f,0.000118100000f,0.000110370000f,0.000103150000f,0.000096427000f,0.000090151000f,0.000084294000f,0.000078830000f,0.000073729000f,0.000068969000f,0.000064525800f,0.000060376000f,0.000056500000f,0.000052880000f,0.000049498000f,0.000046339000f,0.000043389000f,0.000040634000f,0.000038060000f,0.000035657000f,0.000033411700f,0.000031315000f,0.000029355000f,0.000027524000f,0.000025811000f,0.000024209000f,0.000022711000f,0.000021308000f,0.000019994000f,0.000018764000f,0.000017611500f,0.000016532000f,0.000015521000f,0.000014574000f,0.000013686000f,0.000012855000f,0.000012075000f,0.000011345000f,0.000010659000f,0.000010017000f,0.000009413630f,0.000008847900f,0.000008317100f,0.000007819000f,0.000007351600f,0.000006913000f,0.000006501500f,0.000006115300f,0.000005752900f,0.000005412700f,0.000005093470f,0.000004793800f,0.000004512500f,0.000004248300f,0.000004000200f,0.000003767100f,0.000003548000f,0.000003342100f,0.000003148500f,0.000002966500f,0.000002795310f,0.000002634500f,0.000002483400f,0.000002341400f,0.000002207800f,0.000002082000f,0.000001963600f,0.000001851900f,0.000001746500f,0.000001647100f,0.000001553140f };
	static float s_CIE_1964_10deg_Y[] = { 0.000000013398f,0.000000020294f,0.000000030560f,0.000000045740f,0.000000068050f,0.000000100650f,0.000000147980f,0.000000216270f,0.000000314200f,0.000000453700f,0.000000651100f,0.000000928800f,0.000001317500f,0.000001857200f,0.000002602000f,0.000003625000f,0.000005019000f,0.000006907000f,0.000009449000f,0.000012848000f,0.000017364000f,0.000023327000f,0.000031150000f,0.000041350000f,0.000054560000f,0.000071560000f,0.000093300000f,0.000120870000f,0.000155640000f,0.000199200000f,0.000253400000f,0.000320200000f,0.000402400000f,0.000502300000f,0.000623200000f,0.000768500000f,0.000941700000f,0.001147800000f,0.001390300000f,0.001674000000f,0.002004400000f,0.002386000000f,0.002822000000f,0.003319000000f,0.003880000000f,0.004509000000f,0.005209000000f,0.005985000000f,0.006833000000f,0.007757000000f,0.008756000000f,0.009816000000f,0.010918000000f,0.012058000000f,0.013237000000f,0.014456000000f,0.015717000000f,0.017025000000f,0.018399000000f,0.019848000000f,0.021391000000f,0.022992000000f,0.024598000000f,0.026213000000f,0.027841000000f,0.029497000000f,0.031195000000f,0.032927000000f,0.034738000000f,0.036654000000f,0.038676000000f,0.040792000000f,0.042946000000f,0.045114000000f,0.047333000000f,0.049602000000f,0.051934000000f,0.054337000000f,0.056822000000f,0.059399000000f,0.062077000000f,0.064737000000f,0.067285000000f,0.069764000000f,0.072218000000f,0.074704000000f,0.077272000000f,0.079979000000f,0.082874000000f,0.086000000000f,0.089456000000f,0.092947000000f,0.096275000000f,0.099535000000f,0.102829000000f,0.106256000000f,0.109901000000f,0.113835000000f,0.118167000000f,0.122932000000f,0.128201000000f,0.133457000000f,0.138323000000f,0.143042000000f,0.147787000000f,0.152761000000f,0.158102000000f,0.163941000000f,0.170362000000f,0.177425000000f,0.185190000000f,0.193025000000f,0.200313000000f,0.207156000000f,0.213644000000f,0.219940000000f,0.226170000000f,0.232467000000f,0.239025000000f,0.245997000000f,0.253589000000f,0.261876000000f,0.270643000000f,0.279645000000f,0.288694000000f,0.297665000000f,0.306469000000f,0.315035000000f,0.323335000000f,0.331366000000f,0.339133000000f,0.347860000000f,0.358326000000f,0.370001000000f,0.382464000000f,0.395379000000f,0.408482000000f,0.421588000000f,0.434619000000f,0.447601000000f,0.460777000000f,0.474340000000f,0.488200000000f,0.502340000000f,0.516740000000f,0.531360000000f,0.546190000000f,0.561180000000f,0.576290000000f,0.591500000000f,0.606741000000f,0.622150000000f,0.637830000000f,0.653710000000f,0.669680000000f,0.685660000000f,0.701550000000f,0.717230000000f,0.732570000000f,0.747460000000f,0.761757000000f,0.775340000000f,0.788220000000f,0.800460000000f,0.812140000000f,0.823330000000f,0.834120000000f,0.844600000000f,0.854870000000f,0.865040000000f,0.875211000000f,0.885370000000f,0.895370000000f,0.905150000000f,0.914650000000f,0.923810000000f,0.932550000000f,0.940810000000f,0.948520000000f,0.955600000000f,0.961988000000f,0.967540000000f,0.972230000000f,0.976170000000f,0.979460000000f,0.982200000000f,0.984520000000f,0.986520000000f,0.988320000000f,0.990020000000f,0.991761000000f,0.993530000000f,0.995230000000f,0.996770000000f,0.998090000000f,0.999110000000f,0.999770000000f,1.000000000000f,0.999710000000f,0.998850000000f,0.997340000000f,0.995260000000f,0.992740000000f,0.989750000000f,0.986300000000f,0.982380000000f,0.977980000000f,0.973110000000f,0.967740000000f,0.961890000000f,0.955552000000f,0.948601000000f,0.940981000000f,0.932798000000f,0.924158000000f,0.915175000000f,0.905954000000f,0.896608000000f,0.887249000000f,0.877986000000f,0.868934000000f,0.860164000000f,0.851519000000f,0.842963000000f,0.834393000000f,0.825623000000f,0.816764000000f,0.807544000000f,0.797947000000f,0.787893000000f,0.777405000000f,0.766490000000f,0.755309000000f,0.743845000000f,0.732190000000f,0.720353000000f,0.708281000000f,0.696055000000f,0.683621000000f,0.671048000000f,0.658341000000f,0.645545000000f,0.632718000000f,0.619815000000f,0.606887000000f,0.593878000000f,0.580781000000f,0.567653000000f,0.554490000000f,0.541228000000f,0.527963000000f,0.514634000000f,0.501363000000f,0.488124000000f,0.474935000000f,0.461834000000f,0.448823000000f,0.435917000000f,0.423153000000f,0.410526000000f,0.398057000000f,0.385835000000f,0.373951000000f,0.362311000000f,0.350863000000f,0.339554000000f,0.328309000000f,0.317118000000f,0.305936000000f,0.294737000000f,0.283493000000f,0.272222000000f,0.260990000000f,0.249877000000f,0.238946000000f,0.228254000000f,0.217853000000f,0.207780000000f,0.198072000000f,0.188748000000f,0.179828000000f,0.171285000000f,0.163059000000f,0.155151000000f,0.147535000000f,0.140211000000f,0.133170000000f,0.126400000000f,0.119892000000f,0.113640000000f,0.107633000000f,0.101870000000f,0.096347000000f,0.091063000000f,0.086010000000f,0.081187000000f,0.076583000000f,0.072198000000f,0.068024000000f,0.064052000000f,0.060281000000f,0.056697000000f,0.053292000000f,0.050059000000f,0.046998000000f,0.044096000000f,0.041345000000f,0.038750700000f,0.036297800000f,0.033983200000f,0.031800400000f,0.029739500000f,0.027791800000f,0.025955100000f,0.024226300000f,0.022601700000f,0.021077900000f,0.019650500000f,0.018315300000f,0.017068600000f,0.015905100000f,0.014818300000f,0.013800800000f,0.012849500000f,0.011960700000f,0.011130300000f,0.010355500000f,0.009633200000f,0.008959900000f,0.008332400000f,0.007748800000f,0.007204600000f,0.006697500000f,0.006225100000f,0.005785000000f,0.005375100000f,0.004994100000f,0.004639200000f,0.004309300000f,0.004002800000f,0.003717740000f,0.003452620000f,0.003205830000f,0.002976230000f,0.002762810000f,0.002564560000f,0.002380480000f,0.002209710000f,0.002051320000f,0.001904490000f,0.001768470000f,0.001642360000f,0.001525350000f,0.001416720000f,0.001315950000f,0.001222390000f,0.001135550000f,0.001054940000f,0.000980140000f,0.000910660000f,0.000846190000f,0.000786290000f,0.000730680000f,0.000678990000f,0.000631010000f,0.000586440000f,0.000545110000f,0.000506720000f,0.000471110000f,0.000438050000f,0.000407410000f,0.000378962000f,0.000352543000f,0.000328001000f,0.000305208000f,0.000284041000f,0.000264375000f,0.000246109000f,0.000229143000f,0.000213376000f,0.000198730000f,0.000185115000f,0.000172454000f,0.000160678000f,0.000149730000f,0.000139550000f,0.000130086000f,0.000121290000f,0.000113106000f,0.000105501000f,0.000098428000f,0.000091853000f,0.000085738000f,0.000080048000f,0.000074751000f,0.000069819000f,0.000065222000f,0.000060939000f,0.000056942000f,0.000053217000f,0.000049737000f,0.000046491000f,0.000043464000f,0.000040635000f,0.000038000000f,0.000035540500f,0.000033244800f,0.000031100600f,0.000029099000f,0.000027230700f,0.000025486000f,0.000023856100f,0.000022333200f,0.000020910400f,0.000019580800f,0.000018338400f,0.000017177700f,0.000016093400f,0.000015080000f,0.000014133600f,0.000013249000f,0.000012422600f,0.000011649900f,0.000010927700f,0.000010251900f,0.000009619600f,0.000009028100f,0.000008474000f,0.000007954800f,0.000007468600f,0.000007012800f,0.000006585800f,0.000006185700f,0.000005810700f,0.000005459000f,0.000005129800f,0.000004820600f,0.000004531200f,0.000004259100f,0.000004004200f,0.000003764730f,0.000003539950f,0.000003329140f,0.000003131150f,0.000002945290f,0.000002770810f,0.000002607050f,0.000002453290f,0.000002308940f,0.000002173380f,0.000002046130f,0.000001926620f,0.000001814400f,0.000001708950f,0.000001609880f,0.000001516770f,0.000001429210f,0.000001346860f,0.000001269450f,0.000001196620f,0.000001128090f,0.000001063680f,0.000001003130f,0.000000946220f,0.000000892630f,0.000000842160f,0.000000794640f,0.000000749780f,0.000000707440f,0.000000667480f,0.000000629700f };
	static float s_CIE_1964_10deg_Z[] = { 0.000000535027f,0.000000810720f,0.000001221200f,0.000001828700f,0.000002722200f,0.000004028300f,0.000005925700f,0.000008665100f,0.000012596000f,0.000018201000f,0.000026143700f,0.000037330000f,0.000052987000f,0.000074764000f,0.000104870000f,0.000146220000f,0.000202660000f,0.000279230000f,0.000382450000f,0.000520720000f,0.000704776000f,0.000948230000f,0.001268200000f,0.001686100000f,0.002228500000f,0.002927800000f,0.003823700000f,0.004964200000f,0.006406700000f,0.008219300000f,0.010482200000f,0.013289000000f,0.016747000000f,0.020980000000f,0.026127000000f,0.032344000000f,0.039802000000f,0.048691000000f,0.059210000000f,0.071576000000f,0.086010900000f,0.102740000000f,0.122000000000f,0.144020000000f,0.168990000000f,0.197120000000f,0.228570000000f,0.263470000000f,0.301900000000f,0.343870000000f,0.389366000000f,0.437970000000f,0.489220000000f,0.542900000000f,0.598810000000f,0.656760000000f,0.716580000000f,0.778120000000f,0.841310000000f,0.906110000000f,0.972542000000f,1.038900000000f,1.103100000000f,1.165100000000f,1.224900000000f,1.282500000000f,1.338200000000f,1.392600000000f,1.446100000000f,1.499400000000f,1.553480000000f,1.607200000000f,1.658900000000f,1.708200000000f,1.754800000000f,1.798500000000f,1.839200000000f,1.876600000000f,1.910500000000f,1.940800000000f,1.967280000000f,1.989100000000f,2.005700000000f,2.017400000000f,2.024400000000f,2.027300000000f,2.026400000000f,2.022300000000f,2.015300000000f,2.006000000000f,1.994800000000f,1.981400000000f,1.965300000000f,1.946400000000f,1.924800000000f,1.900700000000f,1.874100000000f,1.845100000000f,1.813900000000f,1.780600000000f,1.745370000000f,1.709100000000f,1.672300000000f,1.634700000000f,1.595600000000f,1.554900000000f,1.512200000000f,1.467300000000f,1.419900000000f,1.370000000000f,1.317560000000f,1.262400000000f,1.205000000000f,1.146600000000f,1.088000000000f,1.030200000000f,0.973830000000f,0.919430000000f,0.867460000000f,0.818280000000f,0.772125000000f,0.728290000000f,0.686040000000f,0.645530000000f,0.606850000000f,0.570060000000f,0.535220000000f,0.502340000000f,0.471400000000f,0.442390000000f,0.415254000000f,0.390024000000f,0.366399000000f,0.344015000000f,0.322689000000f,0.302356000000f,0.283036000000f,0.264816000000f,0.247848000000f,0.232318000000f,0.218502000000f,0.205851000000f,0.193596000000f,0.181736000000f,0.170281000000f,0.159249000000f,0.148673000000f,0.138609000000f,0.129096000000f,0.120215000000f,0.112044000000f,0.104710000000f,0.098196000000f,0.092361000000f,0.087088000000f,0.082248000000f,0.077744000000f,0.073456000000f,0.069268000000f,0.065060000000f,0.060709000000f,0.056457000000f,0.052609000000f,0.049122000000f,0.045954000000f,0.043050000000f,0.040368000000f,0.037839000000f,0.035384000000f,0.032949000000f,0.030451000000f,0.028029000000f,0.025862000000f,0.023920000000f,0.022174000000f,0.020584000000f,0.019127000000f,0.017740000000f,0.016403000000f,0.015064000000f,0.013676000000f,0.012308000000f,0.011056000000f,0.009915000000f,0.008872000000f,0.007918000000f,0.007030000000f,0.006223000000f,0.005453000000f,0.004714000000f,0.003988000000f,0.003289000000f,0.002646000000f,0.002063000000f,0.001533000000f,0.001091000000f,0.000711000000f,0.000407000000f,0.000184000000f,0.000047000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f };

	static float s_Illuminance_D65_min = 300.0f;
	static float s_Illuminance_D65_max = 830.0f;
#define s_Illuminance_D65_samplesCount 531
	static float s_Illuminance_D65[] = { 0.034100f,0.360140f,0.686180f,1.012220f,1.338260f,1.664300f,1.990340f,2.316380f,2.642420f,2.968460f,3.294500f,4.988650f,6.682800f,8.376950f,10.071100f,11.765200f,13.459400f,15.153500f,16.847700f,18.541800f,20.236000f,21.917700f,23.599500f,25.281200f,26.963000f,28.644700f,30.326500f,32.008200f,33.690000f,35.371700f,37.053500f,37.343000f,37.632600f,37.922100f,38.211600f,38.501100f,38.790700f,39.080200f,39.369700f,39.659300f,39.948800f,40.445100f,40.941400f,41.437700f,41.934000f,42.430200f,42.926500f,43.422800f,43.919100f,44.415400f,44.911700f,45.084400f,45.257000f,45.429700f,45.602300f,45.775000f,45.947700f,46.120300f,46.293000f,46.465600f,46.638300f,47.183400f,47.728500f,48.273500f,48.818600f,49.363700f,49.908800f,50.453900f,50.998900f,51.544000f,52.089100f,51.877700f,51.666400f,51.455000f,51.243700f,51.032300f,50.820900f,50.609600f,50.398200f,50.186900f,49.975500f,50.442800f,50.910000f,51.377300f,51.844600f,52.311800f,52.779100f,53.246400f,53.713700f,54.180900f,54.648200f,57.458900f,60.269500f,63.080200f,65.890900f,68.701500f,71.512200f,74.322900f,77.133600f,79.944200f,82.754900f,83.628000f,84.501100f,85.374200f,86.247300f,87.120400f,87.993600f,88.866700f,89.739800f,90.612900f,91.486000f,91.680600f,91.875200f,92.069700f,92.264300f,92.458900f,92.653500f,92.848100f,93.042600f,93.237200f,93.431800f,92.756800f,92.081900f,91.406900f,90.732000f,90.057000f,89.382100f,88.707100f,88.032200f,87.357200f,86.682300f,88.500600f,90.318800f,92.137100f,93.955400f,95.773600f,97.591900f,99.410200f,101.228000f,103.047000f,104.865000f,106.079000f,107.294000f,108.508000f,109.722000f,110.936000f,112.151000f,113.365000f,114.579000f,115.794000f,117.008000f,117.088000f,117.169000f,117.249000f,117.330000f,117.410000f,117.490000f,117.571000f,117.651000f,117.732000f,117.812000f,117.517000f,117.222000f,116.927000f,116.632000f,116.336000f,116.041000f,115.746000f,115.451000f,115.156000f,114.861000f,114.967000f,115.073000f,115.180000f,115.286000f,115.392000f,115.498000f,115.604000f,115.711000f,115.817000f,115.923000f,115.212000f,114.501000f,113.789000f,113.078000f,112.367000f,111.656000f,110.945000f,110.233000f,109.522000f,108.811000f,108.865000f,108.920000f,108.974000f,109.028000f,109.082000f,109.137000f,109.191000f,109.245000f,109.300000f,109.354000f,109.199000f,109.044000f,108.888000f,108.733000f,108.578000f,108.423000f,108.268000f,108.112000f,107.957000f,107.802000f,107.501000f,107.200000f,106.898000f,106.597000f,106.296000f,105.995000f,105.694000f,105.392000f,105.091000f,104.790000f,105.080000f,105.370000f,105.660000f,105.950000f,106.239000f,106.529000f,106.819000f,107.109000f,107.399000f,107.689000f,107.361000f,107.032000f,106.704000f,106.375000f,106.047000f,105.719000f,105.390000f,105.062000f,104.733000f,104.405000f,104.369000f,104.333000f,104.297000f,104.261000f,104.225000f,104.190000f,104.154000f,104.118000f,104.082000f,104.046000f,103.641000f,103.237000f,102.832000f,102.428000f,102.023000f,101.618000f,101.214000f,100.809000f,100.405000f,100.000000f,99.633400f,99.266800f,98.900300f,98.533700f,98.167100f,97.800500f,97.433900f,97.067400f,96.700800f,96.334200f,96.279600f,96.225000f,96.170300f,96.115700f,96.061100f,96.006500f,95.951900f,95.897200f,95.842600f,95.788000f,95.077800f,94.367500f,93.657300f,92.947000f,92.236800f,91.526600f,90.816300f,90.106100f,89.395800f,88.685600f,88.817700f,88.949700f,89.081800f,89.213800f,89.345900f,89.478000f,89.610000f,89.742100f,89.874100f,90.006200f,89.965500f,89.924800f,89.884100f,89.843400f,89.802600f,89.761900f,89.721200f,89.680500f,89.639800f,89.599100f,89.409100f,89.219000f,89.029000f,88.838900f,88.648900f,88.458900f,88.268800f,88.078800f,87.888700f,87.698700f,87.257700f,86.816700f,86.375700f,85.934700f,85.493600f,85.052600f,84.611600f,84.170600f,83.729600f,83.288600f,83.329700f,83.370700f,83.411800f,83.452800f,83.493900f,83.535000f,83.576000f,83.617100f,83.658100f,83.699200f,83.332000f,82.964700f,82.597500f,82.230200f,81.863000f,81.495800f,81.128500f,80.761300f,80.394000f,80.026800f,80.045600f,80.064400f,80.083100f,80.101900f,80.120700f,80.139500f,80.158300f,80.177000f,80.195800f,80.214600f,80.420900f,80.627200f,80.833600f,81.039900f,81.246200f,81.452500f,81.658800f,81.865200f,82.071500f,82.277800f,81.878400f,81.479100f,81.079700f,80.680400f,80.281000f,79.881600f,79.482300f,79.082900f,78.683600f,78.284200f,77.427900f,76.571600f,75.715300f,74.859000f,74.002700f,73.146500f,72.290200f,71.433900f,70.577600f,69.721300f,69.910100f,70.098900f,70.287600f,70.476400f,70.665200f,70.854000f,71.042800f,71.231500f,71.420300f,71.609100f,71.883100f,72.157100f,72.431100f,72.705100f,72.979000f,73.253000f,73.527000f,73.801000f,74.075000f,74.349000f,73.074500f,71.800000f,70.525500f,69.251000f,67.976500f,66.702000f,65.427500f,64.153000f,62.878500f,61.604000f,62.432200f,63.260300f,64.088500f,64.916600f,65.744800f,66.573000f,67.401100f,68.229300f,69.057400f,69.885600f,70.405700f,70.925900f,71.446000f,71.966200f,72.486300f,73.006400f,73.526600f,74.046700f,74.566900f,75.087000f,73.937600f,72.788100f,71.638700f,70.489300f,69.339800f,68.190400f,67.041000f,65.891600f,64.742100f,63.592700f,61.875200f,60.157800f,58.440300f,56.722900f,55.005400f,53.288000f,51.570500f,49.853100f,48.135600f,46.418200f,48.456900f,50.495600f,52.534400f,54.573100f,56.611800f,58.650500f,60.689200f,62.728000f,64.766700f,66.805400f,66.463100f,66.120900f,65.778600f,65.436400f,65.094100f,64.751800f,64.409600f,64.067300f,63.725100f,63.382800f,63.474900f,63.567000f,63.659200f,63.751300f,63.843400f,63.935500f,64.027600f,64.119800f,64.211900f,64.304000f,63.818800f,63.333600f,62.848400f,62.363200f,61.877900f,61.392700f,60.907500f,60.422300f,59.937100f,59.451900f,58.702600f,57.953300f,57.204000f,56.454700f,55.705400f,54.956200f,54.206900f,53.457600f,52.708300f,51.959000f,52.507200f,53.055300f,53.603500f,54.151600f,54.699800f,55.248000f,55.796100f,56.344300f,56.892400f,57.440600f,57.727800f,58.015000f,58.302200f,58.589400f,58.876500f,59.163700f,59.450900f,59.738100f,60.025300f,60.312500f };

	static float s_Illuminance_D50_min = 300.0f;
	static float s_Illuminance_D50_max = 780.0f;
#define s_Illuminance_D50_samplesCount 97
	static float s_Illuminance_D50[] = { 0.019f,1.035f,2.051f,4.914f,7.778f,11.263f,14.748f,16.348f,17.948f,19.479f,21.010f,22.476f,23.942f,25.451f,26.961f,25.724f,24.488f,27.179f,29.871f,39.589f,49.308f,52.910f,56.513f,58.273f,60.034f,58.926f,57.818f,66.321f,74.825f,81.036f,87.247f,88.930f,90.612f,90.990f,91.368f,93.238f,95.109f,93.536f,91.963f,93.843f,95.724f,96.169f,96.613f,96.871f,97.129f,99.614f,102.099f,101.427f,100.755f,101.536f,102.317f,101.159f,100.000f,98.868f,97.735f,98.327f,98.918f,96.208f,93.499f,95.593f,97.688f,98.478f,99.269f,99.155f,99.042f,97.382f,95.722f,97.290f,98.857f,97.262f,95.667f,96.929f,98.190f,100.597f,103.003f,101.068f,99.133f,93.257f,87.381f,89.492f,91.604f,92.246f,92.889f,84.872f,76.854f,81.683f,86.511f,89.546f,92.580f,85.405f,78.230f,67.961f,57.692f,70.307f,82.923f,80.599f,78.274f };

	static float* s_CIE_Observers_X[] = { s_CIE_1931_2deg_X, s_CIE_1964_10deg_X };
	static float* s_CIE_Observers_Y[] = { s_CIE_1931_2deg_Y, s_CIE_1964_10deg_Y };
	static float* s_CIE_Observers_Z[] = { s_CIE_1931_2deg_Z, s_CIE_1964_10deg_Z };
	static float s_CIE_Observers_min[] = { s_CIE_1931_2deg_min, s_CIE_1964_10deg_min };
	static float s_CIE_Observers_max[] = { s_CIE_1931_2deg_max, s_CIE_1964_10deg_max };
	static int s_CIE_Observers_SamplesCount[] = { s_CIE_1931_2deg_samplesCount, s_CIE_1964_10deg_samplesCount };

	static float* s_Illums[] = { s_Illuminance_D50, s_Illuminance_D65 };
	static float s_Illums_min[] = { s_Illuminance_D50_min, s_Illuminance_D65_min };
	static float s_Illums_max[] = { s_Illuminance_D50_max, s_Illuminance_D65_max };
	static int s_Illums_SamplesCount[] = { s_Illuminance_D50_samplesCount, s_Illuminance_D65_samplesCount };

	// White Points
	// { 1932-2° {x, y}, 1964-10° {x, y}, Temperature Kelvin }
	static ImVec2 s_WhitePoints_Values[][2] =
	{
		{ ImVec2(0.44757f, 0.40745f), ImVec2(0.45117f, 0.40594f) }, // A:	incandescent / tungsten
		{ ImVec2(0.34842f, 0.35161f), ImVec2(0.34980f, 0.35270f) }, // B:	obsolete, direct sunlight at noon
		{ ImVec2(0.31006f, 0.31616f), ImVec2(0.31039f, 0.31905f) }, // C:	obsolete, average / North sky daylight
		{ ImVec2(0.34567f, 0.35850f), ImVec2(0.34773f, 0.35952f) }, // D50:	horizon light, ICC profile PCS
		{ ImVec2(0.33242f, 0.34743f), ImVec2(0.33411f, 0.34877f) }, // D55:	mid-morning / mid-afternoon daylight
		{ ImVec2(0.31271f, 0.32902f), ImVec2(0.31382f, 0.33100f) }, // D65:	noon daylight: television, sRGB color space
		{ ImVec2(0.29902f, 0.31485f), ImVec2(0.29968f, 0.31740f) }, // D75:	North sky daylight
		{ ImVec2(0.28315f, 0.29711f), ImVec2(0.28327f, 0.30043f) }, // D93:	high-efficiency blue phosphor monitors, BT.2035
		{ ImVec2(0.33333f, 0.33333f), ImVec2(0.33333f, 0.33333f) }, // E:	equal energy
		{ ImVec2(0.31310f, 0.33727f), ImVec2(0.31811f, 0.33559f) }, // F1:	daylight fluorescent
		{ ImVec2(0.37208f, 0.37529f), ImVec2(0.37925f, 0.36733f) }, // F2:	cool white fluorescent
		{ ImVec2(0.40910f, 0.39430f), ImVec2(0.41761f, 0.38324f) }, // F3:	white fluorescent
		{ ImVec2(0.44018f, 0.40329f), ImVec2(0.44920f, 0.39074f) }, // F4:	warm white fluorescent
		{ ImVec2(0.31379f, 0.34531f), ImVec2(0.31975f, 0.34246f) }, // F5:	daylight fluorescent
		{ ImVec2(0.37790f, 0.38835f), ImVec2(0.38660f, 0.37847f) }, // F6:	light white fluorescent
		{ ImVec2(0.31292f, 0.32933f), ImVec2(0.31569f, 0.32960f) }, // F7:	D65 simulator, daylight simulator
		{ ImVec2(0.34588f, 0.35875f), ImVec2(0.34902f, 0.35939f) }, // F8:	D50 simulator, Sylvania F40 Design 50
		{ ImVec2(0.37417f, 0.37281f), ImVec2(0.37829f, 0.37045f) }, // F9:	cool white deluxe fluorescent
		{ ImVec2(0.34609f, 0.35986f), ImVec2(0.35090f, 0.35444f) }, // F10:	Philips TL85, Ultralume 50
		{ ImVec2(0.38052f, 0.37713f), ImVec2(0.38541f, 0.37123f) }, // F11:	Philips TL84, Ultralume 40
		{ ImVec2(0.43695f, 0.40441f), ImVec2(0.44256f, 0.39717f) }  // F12:	Philips TL83, Ultralume 30
	};
	static float s_WhitePoints_Temperature[] =
	{
		2856.0f, 4874.0f, 6774.0f, 5003.0f, 5503.0f, 6504.0f, 7504.0f,
		9305.0f, 5454.0f, 6430.0f, 4230.0f, 3450.0f, 2940.0f, 6350.0f,
		4150.0f, 6500.0f, 5000.0f, 4150.0f, 5000.0f, 4000.0f, 3000.0f
	};

	// Color Space
	static float s_ColorSpace_XYZ2RGB_AdobeRGB[] = { 2.0413690f, -0.5649464f, -0.3446944, -0.9692660f, 1.8760108f, 0.0415560, 0.0134474f, -0.1183897f, 1.0154096f };
	static float s_ColorSpace_XYZ2RGB_AppleRGB[] = { 2.9515373f, -1.2894116f, -0.4738445f, -1.0851093f, 1.9908566f, 0.0372026f, 0.0854934f, -0.2694964f, 1.0912975f };
	static float s_ColorSpace_XYZ2RGB_Best[] = { 1.7552599f, -0.4836786f, -0.2530000f, -0.5441336f, 1.5068789f, 0.0215528f, 0.0063467f, -0.0175761f, 1.2256959f };
	static float s_ColorSpace_XYZ2RGB_Beta[] = { 1.6832270f, -0.4282363f, -0.2360185f, -0.7710229f, 1.7065571f, 0.0446900f, 0.0400013f, -0.0885376f, 1.2723640f };
	static float s_ColorSpace_XYZ2RGB_Bruce[] = { 2.7454669f, -1.1358136f, -0.4350269f, -0.9692660f, 1.8760108f, 0.0415560f, 0.0112723f, -0.1139754f, 1.0132541f };
	static float s_ColorSpace_XYZ2RGB_CIERGB[] = { 2.3706743f, -0.9000405f, -0.4706338f, -0.5138850f, 1.4253036f, 0.0885814f, 0.0052982f, -0.0146949f, 1.0093968f };
	static float s_ColorSpace_XYZ2RGB_ColorMatch[] = { 2.6422874f, -1.2234270f, -0.3930143f, -1.1119763f, 2.0590183f, 0.0159614f, 0.0821699f, -0.2807254f, 1.4559877f };
	static float s_ColorSpace_XYZ2RGB_DonRGB4[] = { 1.7603902f, -0.4881198f, -0.2536126f, -0.7126288f, 1.6527432f, 0.0416715f, 0.0078207f, -0.0347411f, 1.2447743f };
	static float s_ColorSpace_XYZ2RGB_ECI[] = { 1.7827618f, -0.4969847f, -0.2690101f, -0.9593623f, 1.9477962f, -0.0275807f, 0.0859317f, -0.1744674f, 1.3228273f };
	static float s_ColorSpace_XYZ2RGB_EktaSpacePS5[] = { 2.0043819f, -0.7304844f, -0.2450052f, -0.7110285f, 1.6202126f, 0.0792227f, 0.0381263f, -0.0868780f, 1.2725438 };
	static float s_ColorSpace_XYZ2RGB_NTSC[] = { 1.9099961f, -0.5324542f, -0.2882091f, -0.9846663f, 1.9991710f, -0.0283082f, 0.0583056f, -0.1183781f, 0.8975535f };
	static float s_ColorSpace_XYZ2RGB_PAL_SECAM[] = { 3.0628971f, -1.3931791f, -0.4757517f, -0.9692660f, 1.8760108f, 0.0415560f, 0.0678775f, -0.2288548f, 1.0693490f };
	static float s_ColorSpace_XYZ2RGB_ProPhoto[] = { 1.3459433f, -0.2556075f, -0.0511118f, -0.5445989f, 1.5081673f, 0.0205351f, 0.0000000f, 0.0000000f, 1.2118128f };
	static float s_ColorSpace_XYZ2RGB_SMPTE_C[] = { 3.5053960f, -1.7394894f, -0.5439640f, -1.0690722f, 1.9778245f, 0.0351722f, 0.0563200f, -0.1970226f, 1.0502026f };
	static float s_ColorSpace_XYZ2RGB_sRGB[] = { 3.2404542f, -1.5371385f, -0.4985314f, -0.9692660f, 1.8760108f, 0.0415560f, 0.0556434f, -0.2040259f, 1.0572252f };
	static float s_ColorSpace_XYZ2RGB_WideGamutRGB[] = { 1.4628067f, -0.1840623f, -0.2743606f, -0.5217933f, 1.4472381f, 0.0677227f, 0.0349342f, -0.0968930f, 1.2884099f };
	static float s_ColorSpace_XYZ2RGB_Rec2020[] = { 1.7166512f, -0.3556708f, -0.2533663f, -0.6666844f, 1.6164812f, 0.0157685f, 0.0176399f, -0.0427706f, 0.9421031f };
	static float* s_ColorSpace_XYZ2RGB[] = { s_ColorSpace_XYZ2RGB_AdobeRGB, s_ColorSpace_XYZ2RGB_AppleRGB, s_ColorSpace_XYZ2RGB_Best, s_ColorSpace_XYZ2RGB_Beta,
		s_ColorSpace_XYZ2RGB_Bruce, s_ColorSpace_XYZ2RGB_CIERGB, s_ColorSpace_XYZ2RGB_ColorMatch, s_ColorSpace_XYZ2RGB_DonRGB4,
		s_ColorSpace_XYZ2RGB_ECI, s_ColorSpace_XYZ2RGB_EktaSpacePS5, s_ColorSpace_XYZ2RGB_NTSC, s_ColorSpace_XYZ2RGB_PAL_SECAM,
		s_ColorSpace_XYZ2RGB_ProPhoto, s_ColorSpace_XYZ2RGB_SMPTE_C, s_ColorSpace_XYZ2RGB_sRGB, s_ColorSpace_XYZ2RGB_WideGamutRGB,
		s_ColorSpace_XYZ2RGB_Rec2020 };
	static float s_ColorSpace_Gamma[] = { 2.2f, 1.8f, 2.2f, 2.2f, 2.2f, 2.2f, 1.8f, 2.2f, 1.0f, 2.2f, 2.2f, 2.2f, 1.8f, 2.2f, 2.2f, 2.2f, 2.2f };
	// xy: { {xy}:RR, {xy}:GG, {xy}:BB }
	static ImVec2 s_ColorSpace_Primaries[][3] = {
		{ ImVec2(0.6400f, 0.3300f), ImVec2(0.2100f, 0.7100f), ImVec2(0.1500f, 0.0600f) },	// AdobeRBG
		{ ImVec2(0.6250f, 0.3400f), ImVec2(0.2800f, 0.5950f), ImVec2(0.1550f, 0.0700f) },	// AppleRGB
		{ ImVec2(0.7347f, 0.2653f), ImVec2(0.2150f, 0.7750f), ImVec2(0.1300f, 0.0350f) },	// Best
		{ ImVec2(0.6888f, 0.3112f), ImVec2(0.1986f, 0.7551f), ImVec2(0.1265f, 0.0352f) },	// Beta
		{ ImVec2(0.6400f, 0.3300f), ImVec2(0.2800f, 0.6500f), ImVec2(0.1500f, 0.0600f) },	// Bruce
		{ ImVec2(0.7350f, 0.2650f), ImVec2(0.2740f, 0.7170f), ImVec2(0.1670f, 0.0090f) },	// CIERGB
		{ ImVec2(0.6300f, 0.3400f), ImVec2(0.2950f, 0.6050f), ImVec2(0.1500f, 0.0750f) },	// ColorMatch
		{ ImVec2(0.6960f, 0.3000f), ImVec2(0.2150f, 0.7650f), ImVec2(0.1300f, 0.0350f) },	// DonRGB4
		{ ImVec2(0.6700f, 0.3300f), ImVec2(0.2100f, 0.7100f), ImVec2(0.1400f, 0.0800f) },	// ECI
		{ ImVec2(0.6950f, 0.3050f), ImVec2(0.2600f, 0.7000f), ImVec2(0.1100f, 0.0050f) },	// EktaSpacePS5
		{ ImVec2(0.6700f, 0.3300f), ImVec2(0.2100f, 0.7100f), ImVec2(0.1400f, 0.0800f) },	// NTSC
		{ ImVec2(0.6400f, 0.3300f), ImVec2(0.2900f, 0.6000f), ImVec2(0.1500f, 0.0600f) },	// PAL/SECAM
		{ ImVec2(0.7347f, 0.2653f), ImVec2(0.1596f, 0.8404f), ImVec2(0.0366f, 0.0001f) },	// ProPhoto
		{ ImVec2(0.6300f, 0.3400f), ImVec2(0.3100f, 0.5950f), ImVec2(0.1550f, 0.0700f) },	// SMPTE-C
		{ ImVec2(0.6400f, 0.3300f), ImVec2(0.3000f, 0.6000f), ImVec2(0.1500f, 0.0600f) },	// sRGB
		{ ImVec2(0.7350f, 0.2650f), ImVec2(0.1150f, 0.8260f), ImVec2(0.1570f, 0.0180f) },	// Wide Gamut
		{ ImVec2(0.7080f, 0.2920f), ImVec2(0.1700f, 0.7970f), ImVec2(0.1310f, 0.0460f) }	// Rec2020
	};
	static int s_ColorSpace_WhitePointIndex[] =
	{
		ImWidgetsWhitePointChromaticPlot_D65,
		ImWidgetsWhitePointChromaticPlot_D65,
		ImWidgetsWhitePointChromaticPlot_D50,
		ImWidgetsWhitePointChromaticPlot_D50,
		ImWidgetsWhitePointChromaticPlot_D65,
		ImWidgetsWhitePointChromaticPlot_E,
		ImWidgetsWhitePointChromaticPlot_D50,
		ImWidgetsWhitePointChromaticPlot_D50,
		ImWidgetsWhitePointChromaticPlot_D50,
		ImWidgetsWhitePointChromaticPlot_D50,
		ImWidgetsWhitePointChromaticPlot_C,
		ImWidgetsWhitePointChromaticPlot_D65,
		ImWidgetsWhitePointChromaticPlot_D50,
		ImWidgetsWhitePointChromaticPlot_D65,
		ImWidgetsWhitePointChromaticPlot_D65,
		ImWidgetsWhitePointChromaticPlot_D50,
		ImWidgetsWhitePointChromaticPlot_D65
	};

	//////////////////////////////////////////////////////////////////////////
	// Helpers
	//////////////////////////////////////////////////////////////////////////
	void	ScaleData(ImGuiDataType data_type, void* p_data, double value)
	{
		switch (data_type)
		{
		case ImGuiDataType_S8:
			*reinterpret_cast<ImS8*>(p_data) *= static_cast<ImS8>(value);
			break;
		case ImGuiDataType_U8:
			*reinterpret_cast<ImU8*>(p_data) *= static_cast<ImU8>(value);
			break;
		case ImGuiDataType_S16:
			*reinterpret_cast<ImS16*>(p_data) *= static_cast<ImS16>(value);
			break;
		case ImGuiDataType_U16:
			*reinterpret_cast<ImU16*>(p_data) *= static_cast<ImU16>(value);
			break;
		case ImGuiDataType_S32:
			*reinterpret_cast<ImS32*>(p_data) *= static_cast<ImS32>(value);
			break;
		case ImGuiDataType_U32:
			*reinterpret_cast<ImU32*>(p_data) *= static_cast<ImU32>(value);
			break;
		case ImGuiDataType_S64:
			*reinterpret_cast<ImS64*>(p_data) *= static_cast<ImS64>(value);
			break;
		case ImGuiDataType_U64:
			*reinterpret_cast<ImU64*>(p_data) *= static_cast<ImU64>(value);
			break;
		case ImGuiDataType_Float:
			*reinterpret_cast<float*>(p_data) *= static_cast<float>(value);
			break;
		case ImGuiDataType_Double:
			*reinterpret_cast<double*>(p_data) *= value;

			break;
		}
	}

	template < typename Type >
	Type	Normalize01(Type const x, Type const _min, Type const _max)
	{
		return (x - _min) / (_max - _min);
	}
	template < typename Type >
	Type	ScaleFromNormalized(Type const x, Type const newMin, Type const newMax)
	{
		return x * (newMax - newMin) + newMin;
	}
	template < typename Type >
	Type	Rescale(Type const x, Type const _min, Type const _max, Type const newMin, Type const newMax)
	{
		return ScaleFromNormalized(Normalize01(x, _min, _max), newMin, newMax);
	}

	bool	IsNegativeScalar(ImGuiDataType data_type, ImU64* src)
	{
		switch (data_type)
		{
		case ImGuiDataType_S8:
		{
			ImS8 value = *reinterpret_cast<ImS8*>(src);
			return value < 0;
		}
		break;
		case ImGuiDataType_S16:
		{
			ImS16 value = *reinterpret_cast<ImS16*>(src);
			return value < 0;
		}
		break;
		case ImGuiDataType_S32:
		{
			ImS32 value = *reinterpret_cast<ImS32*>(src);
			return value < 0l;
		}
		break;
		case ImGuiDataType_S64:
		{
			ImS64 value = *reinterpret_cast<ImS64*>(src);
			return value < 0ll;
		}
		break;
		case ImGuiDataType_U8:
		case ImGuiDataType_U16:
		case ImGuiDataType_U32:
		case ImGuiDataType_U64:
		{
			return false;
		}
		break;
		case ImGuiDataType_Float:
		{
			float value = *reinterpret_cast<float*>(src);
			return value < 0.0f;
		}
		break;
		case ImGuiDataType_Double:
		{
			double value = *reinterpret_cast<double*>(src);
			return value < 0.0f;
		}
		break;
		}

		return false;
	}

	bool	IsPositiveScalar(ImGuiDataType data_type, ImU64* src)
	{
		return !IsNegativeScalar(data_type, src);
	}

	template <typename TypeSrc>
	ImU64	SetScalar(ImGuiDataType data_type, TypeSrc src)
	{
		ImU64 result;
		switch (data_type)
		{
		case ImGuiDataType_S8:
		{
			ImS8 value = static_cast<ImS8>(src);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U8:
		{
			ImU8 value = static_cast<ImU8>(src);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S16:
		{
			ImS16 value = static_cast<ImS16>(src);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U16:
		{
			ImU16 value = static_cast<ImU16>(src);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S32:
		{
			ImS32 value = static_cast<ImS32>(src);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U32:
		{
			ImU32 value = static_cast<ImU32>(src);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S64:
		{
			ImS64 value = static_cast<ImS64>(src);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U64:
		{
			ImU64 value = static_cast<ImU64>(src);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_Float:
		{
			float value = static_cast<float>(src);
			result = *reinterpret_cast<ImU64*>(&value);
		}
		break;
		case ImGuiDataType_Double:
		{
			double value = static_cast<double>(src);
			result = *reinterpret_cast<ImU64*>(&value);
		}
		break;
		}

		return result;
	}

	void	EqualScalar(ImGuiDataType data_type, ImU64* p_target, ImU64* p_source)
	{
		switch (data_type)
		{
		case ImGuiDataType_S8:
			*reinterpret_cast<ImS8*>(p_target) = *reinterpret_cast<ImS8*>(p_source);
			break;
		case ImGuiDataType_U8:
			*reinterpret_cast<ImU8*>(p_target) = *reinterpret_cast<ImU8*>(p_source);
			break;
		case ImGuiDataType_S16:
			*reinterpret_cast<ImS16*>(p_target) = *reinterpret_cast<ImS16*>(p_source);
			break;
		case ImGuiDataType_U16:
			*reinterpret_cast<ImU16*>(p_target) = *reinterpret_cast<ImU16*>(p_source);
			break;
		case ImGuiDataType_S32:
			*reinterpret_cast<ImS32*>(p_target) = *reinterpret_cast<ImS32*>(p_source);
			break;
		case ImGuiDataType_U32:
			*reinterpret_cast<ImU64*>(p_target) = *reinterpret_cast<ImU32*>(p_source);
			break;
		case ImGuiDataType_S64:
			*reinterpret_cast<ImS64*>(p_target) = *reinterpret_cast<ImS64*>(p_source);
			break;
		case ImGuiDataType_U64:
			*reinterpret_cast<ImU64*>(p_target) = *reinterpret_cast<ImU64*>(p_source);
			break;
		case ImGuiDataType_Float:
			*reinterpret_cast<float*>(p_target) = *reinterpret_cast<float*>(p_source);
			break;
		case ImGuiDataType_Double:
			*reinterpret_cast<double*>(p_target) = *reinterpret_cast<double*>(p_source);
			break;
		}
	}

	float	ScalarToFloat(ImGuiDataType data_type, ImU64* p_source)
	{
		switch (data_type)
		{
		case ImGuiDataType_S8:
			return static_cast<float>(*reinterpret_cast<ImS8*>(p_source));
		case ImGuiDataType_U8:
			return static_cast<float>(*reinterpret_cast<ImU8*>(p_source));
		case ImGuiDataType_S16:
			return static_cast<float>(*reinterpret_cast<ImS16*>(p_source));
		case ImGuiDataType_U16:
			return static_cast<float>(*reinterpret_cast<ImU16*>(p_source));
		case ImGuiDataType_S32:
			return static_cast<float>(*reinterpret_cast<ImS32*>(p_source));
		case ImGuiDataType_U32:
			return static_cast<float>(*reinterpret_cast<ImU32*>(p_source));
		case ImGuiDataType_S64:
			return static_cast<float>(*reinterpret_cast<ImS64*>(p_source));
		case ImGuiDataType_U64:
			return static_cast<float>(*reinterpret_cast<ImU64*>(p_source));
		case ImGuiDataType_Float:
			return static_cast<float>(*reinterpret_cast<float*>(p_source));
		case ImGuiDataType_Double:
			return static_cast<float>(*reinterpret_cast<double*>(p_source));
		}

		return 0.0f;
	}

	ImU64	FloatToScalar(ImGuiDataType data_type, float f_value)
	{
		switch (data_type)
		{
		case ImGuiDataType_S8:
		{
			ImS8 value = static_cast<ImS8>(f_value);
			return static_cast<ImU64>(value);
		}
		case ImGuiDataType_U8:
		{
			ImU8 value = static_cast<ImU8>(f_value);
			return static_cast<ImU64>(value);
		}
		case ImGuiDataType_S16:
		{
			ImS16 value = static_cast<ImS16>(f_value);
			return static_cast<ImU64>(value);
		}
		case ImGuiDataType_U16:
		{
			ImU16 value = static_cast<ImU16>(f_value);
			return static_cast<ImU64>(value);
		}
		case ImGuiDataType_S32:
		{
			ImS32 value = static_cast<ImS32>(f_value);
			return static_cast<ImU64>(value);
		}
		case ImGuiDataType_U32:
		{
			ImU32 value = static_cast<ImU32>(f_value);
			return static_cast<ImU64>(value);
		}
		case ImGuiDataType_S64:
		{
			ImS64 value = static_cast<ImS64>(f_value);
			return static_cast<ImU64>(value);
		}
		case ImGuiDataType_U64:
		{
			ImU64 value = static_cast<ImU64>(f_value);
			return static_cast<ImU64>(value);
		}
		case ImGuiDataType_Float:
		{
			float value = f_value;
			return *reinterpret_cast<ImU64*>(&value);
		}
		case ImGuiDataType_Double:
		{
			double value = static_cast<double>(f_value);
			return *reinterpret_cast<ImU64*>(&value);
		}
		}

		return ImU64();
	}

	ImU64	AddScalar(ImGuiDataType data_type, void* p_a, void* p_b)
	{
		ImU64 result;
		switch (data_type)
		{
		case ImGuiDataType_S8:
		{
			ImS8 value = *reinterpret_cast<ImS8*>(p_a) + *static_cast<ImS8*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U8:
		{
			ImU8 value = *reinterpret_cast<ImU8*>(p_a) + *static_cast<ImU8*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S16:
		{
			ImS16 value = *reinterpret_cast<ImS16*>(p_a) + *static_cast<ImS16*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U16:
		{
			ImU16 value = *reinterpret_cast<ImU16*>(p_a) + *static_cast<ImU16*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S32:
		{
			ImS32 value = *reinterpret_cast<ImS32*>(p_a) + *static_cast<ImS32*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U32:
		{
			ImU32 value = *reinterpret_cast<ImU32*>(p_a) + *static_cast<ImU32*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S64:
		{
			ImS64 value = *reinterpret_cast<ImS64*>(p_a) + *static_cast<ImS64*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U64:
		{
			ImU64 value = *reinterpret_cast<ImU64*>(p_a) + *static_cast<ImU64*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_Float:
		{
			float value = *reinterpret_cast<float*>(p_a) + *static_cast<float*>(p_b);
			result = *reinterpret_cast<ImU64*>(&value);
		}
		break;
		case ImGuiDataType_Double:
		{
			double value = *reinterpret_cast<double*>(p_a) + *static_cast<double*>(p_b);
			result = *reinterpret_cast<ImU64*>(&value);
		}
		break;
		}

		return result;
	}

	ImU64	SubScalar(ImGuiDataType data_type, void* p_a, void* p_b)
	{
		ImU64 result = 0;
		switch (data_type)
		{
		case ImGuiDataType_S8:
		{
			ImS8 value = *reinterpret_cast<ImS8*>(p_a) - *static_cast<ImS8*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U8:
		{
			ImU8 value = *reinterpret_cast<ImU8*>(p_a) - *static_cast<ImU8*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S16:
		{
			ImS16 value = *reinterpret_cast<ImS16*>(p_a) - *static_cast<ImS16*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U16:
		{
			ImU16 value = *reinterpret_cast<ImU16*>(p_a) - *static_cast<ImU16*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S32:
		{
			ImS32 value = *reinterpret_cast<ImS32*>(p_a) - *static_cast<ImS32*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U32:
		{
			ImU32 value = *reinterpret_cast<ImU32*>(p_a) - *static_cast<ImU32*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S64:
		{
			ImS64 value = *reinterpret_cast<ImS64*>(p_a) - *static_cast<ImS64*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U64:
		{
			ImU64 value = *reinterpret_cast<ImU64*>(p_a) - *static_cast<ImU64*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_Float:
		{
			float value = *reinterpret_cast<float*>(p_a) - *static_cast<float*>(p_b);
			result = *reinterpret_cast<ImU64*>(&value);
		}
		break;
		case ImGuiDataType_Double:
		{
			double value = *reinterpret_cast<double*>(p_a) - *static_cast<double*>(p_b);
			result = *reinterpret_cast<ImU64*>(&value);
		}
		break;
		}

		return result;
	}

	ImU64	MulScalar(ImGuiDataType data_type, void* p_a, void* p_b)
	{
		ImU64 result;
		switch (data_type)
		{
		case ImGuiDataType_S8:
		{
			ImS8 value = *reinterpret_cast<ImS8*>(p_a) * *static_cast<ImS8*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U8:
		{
			ImU8 value = *reinterpret_cast<ImU8*>(p_a) * *static_cast<ImU8*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S16:
		{
			ImS16 value = *reinterpret_cast<ImS16*>(p_a) * *static_cast<ImS16*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U16:
		{
			ImU16 value = *reinterpret_cast<ImU16*>(p_a) * *static_cast<ImU16*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S32:
		{
			ImS32 value = *reinterpret_cast<ImS32*>(p_a) * *static_cast<ImS32*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U32:
		{
			ImU32 value = *reinterpret_cast<ImU32*>(p_a) * *static_cast<ImU32*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S64:
		{
			ImS64 value = *reinterpret_cast<ImS64*>(p_a) * *static_cast<ImS64*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U64:
		{
			ImU64 value = *reinterpret_cast<ImU64*>(p_a) * *static_cast<ImU64*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_Float:
		{
			float value = *reinterpret_cast<float*>(p_a) * *static_cast<float*>(p_b);
			result = *reinterpret_cast<ImU64*>(&value);
		}
		break;
		case ImGuiDataType_Double:
		{
			double value = *reinterpret_cast<double*>(p_a) * *static_cast<double*>(p_b);
			result = *reinterpret_cast<ImU64*>(&value);
		}
		break;
		}

		return result;
	}

	ImU64	DivScalar(ImGuiDataType data_type, void* p_a, void* p_b)
	{
		ImU64 result;
		switch (data_type)
		{
		case ImGuiDataType_S8:
		{
			ImS8 value = *reinterpret_cast<ImS8*>(p_a) / *static_cast<ImS8*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U8:
		{
			ImU8 value = *reinterpret_cast<ImU8*>(p_a) / *static_cast<ImU8*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S16:
		{
			ImS16 value = *reinterpret_cast<ImS16*>(p_a) / *static_cast<ImS16*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U16:
		{
			ImU16 value = *reinterpret_cast<ImU16*>(p_a) / *static_cast<ImU16*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S32:
		{
			ImS32 value = *reinterpret_cast<ImS32*>(p_a) / *static_cast<ImS32*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U32:
		{
			ImU32 value = *reinterpret_cast<ImU32*>(p_a) / *static_cast<ImU32*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S64:
		{
			ImS64 value = *reinterpret_cast<ImS64*>(p_a) / *static_cast<ImS64*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U64:
		{
			ImU64 value = *reinterpret_cast<ImU64*>(p_a) / *static_cast<ImU64*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_Float:
		{
			float value = *reinterpret_cast<float*>(p_a) / *static_cast<float*>(p_b);
			result = *reinterpret_cast<ImU64*>(&value);
		}
		break;
		case ImGuiDataType_Double:
		{
			double value = *reinterpret_cast<double*>(p_a) / *static_cast<double*>(p_b);
			result = *reinterpret_cast<ImU64*>(&value);
		}
		break;
		}

		return result;
	}

	ImU64	ClampScalar(ImGuiDataType data_type, void* p_value, void* p_min, void* p_max)
	{
		ImU64 result = 0;
		switch (data_type)
		{
		case ImGuiDataType_S8:
		{
			ImS8 value = ImClamp(*reinterpret_cast<ImS8*>(p_value), *static_cast<ImS8*>(p_min), *static_cast<ImS8*>(p_max));
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U8:
		{
			ImU8 value = ImClamp(*reinterpret_cast<ImU8*>(p_value), *static_cast<ImU8*>(p_min), *static_cast<ImU8*>(p_max));
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S16:
		{
			ImS16 value = ImClamp(*reinterpret_cast<ImS16*>(p_value), *static_cast<ImS16*>(p_min), *static_cast<ImS16*>(p_max));
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U16:
		{
			ImU16 value = ImClamp(*reinterpret_cast<ImU16*>(p_value), *static_cast<ImU16*>(p_min), *static_cast<ImU16*>(p_max));
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S32:
		{
			ImS32 value = ImClamp(*reinterpret_cast<ImS32*>(p_value), *static_cast<ImS32*>(p_min), *static_cast<ImS32*>(p_max));
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U32:
		{
			ImU32 value = ImClamp(*reinterpret_cast<ImU32*>(p_value), *static_cast<ImU32*>(p_min), *static_cast<ImU32*>(p_max));
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S64:
		{
			ImS64 value = ImClamp(*reinterpret_cast<ImS64*>(p_value), *static_cast<ImS64*>(p_min), *static_cast<ImS64*>(p_max));
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U64:
		{
			ImU64 value = ImClamp(*reinterpret_cast<ImU64*>(p_value), *static_cast<ImU64*>(p_min), *static_cast<ImU64*>(p_max));
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_Float:
		{
			float value = ImClamp(*reinterpret_cast<float*>(p_value), *static_cast<float*>(p_min), *static_cast<float*>(p_max));
			result = *reinterpret_cast<ImU64*>(&value);
		}
		break;
		case ImGuiDataType_Double:
		{
			double value = ImClamp(*reinterpret_cast<double*>(p_value), *static_cast<double*>(p_min), *static_cast<double*>(p_max));
			result = *reinterpret_cast<ImU64*>(&value);
		}
		break;
		}

		return result;
	}

	float	Dot3(float x0, float x1, float x2, float* vec3)
	{
		return x0 * vec3[0] + x1 * vec3[1] + x2 * vec3[2];
	}

	void	Mat33MulV(float* z0, float* z1, float* z2, float x, float y, float z, float* mat)
	{
		*z0 = Dot3(x, y, z, &mat[0]);
		*z1 = Dot3(x, y, z, &mat[3]);
		*z2 = Dot3(x, y, z, &mat[6]);
	}

#pragma optimize( "", off )
	float	LinearSample(float t, float* buffer, int count)
	{
#if 0
		float const width = (float)(count - 1);

		float tx = ScaleFromNormalized(t, 0.0f, width);

		float i0 = ImFloor(tx);
		float i1 = ImCeil(tx);

		float t0 = i0 / width;
		float t1 = i1 / width;

		float ti;
		if (t0 != t1)
			ti = Normalize01(t, t0, t1);
		else
			ti = 1.0f;

		return ImLerp(buffer[(int)i0], buffer[(int)i1], ti);
#else
		float const width = (float)(count - 1);

		float const i0 = ImFloor(t * width);
		float const i1 = ImCeil(t * width);

		float ti;
		if (i0 != i1)
			ti = (t * width - i0) / (i1 - i0);
		else
			ti = 1.0f;

		return ImLerp(buffer[(int)i0], buffer[(int)i1], ti);
#endif
	}

	void		MemoryString(std::string& sResult, ImU64 const uMemoryByte)
	{
		if (uMemoryByte < ImWidget_Kibi)
		{
			sResult = std::to_string(static_cast<float>(uMemoryByte)) + " B";
		}
		else if (uMemoryByte < ImWidget_Mibi)
		{
			sResult = std::to_string(static_cast<float>(uMemoryByte) / static_cast<float>(ImWidget_Kibi)) + " KiB";
		}
		else if (uMemoryByte < ImWidget_Gibi)
		{
			sResult = std::to_string(static_cast<float>(uMemoryByte) / static_cast<float>(ImWidget_Mibi)) + " MiB";
		}
		else if (uMemoryByte < ImWidget_Tebi)
		{
			sResult = std::to_string(static_cast<float>(uMemoryByte) / static_cast<float>(ImWidget_Gibi)) + " GiB";
		}
		else if (uMemoryByte < ImWidget_Pebi)
		{
			sResult = std::to_string(static_cast<float>(uMemoryByte) / static_cast<float>(ImWidget_Tebi)) + " TiB";
		}
	}

	void		TimeString(std::string& sResult, ImU64 const uNanoseconds)
	{
		std::chrono::nanoseconds oDuration( uNanoseconds );

		typedef std::chrono::duration< ImU64, std::ratio_multiply< std::chrono::hours::period, std::ratio< 8 > >::type > Days; // UTC: +8:00

		Days oDays			= std::chrono::duration_cast< Days >( oDuration );
		oDuration -= oDays;
		auto oHours			= std::chrono::duration_cast< std::chrono::hours >( oDuration );
		oDuration -= oHours;
		auto oMinutes		= std::chrono::duration_cast< std::chrono::minutes >( oDuration );
		oDuration -= oMinutes;
		auto oSeconds		= std::chrono::duration_cast< std::chrono::seconds >( oDuration );
		oDuration -= oSeconds;
		auto oMilliseconds	= std::chrono::duration_cast< std::chrono::milliseconds >( oDuration );
		oDuration -= oMilliseconds;
		auto oMicroseconds	= std::chrono::duration_cast< std::chrono::microseconds >( oDuration );
		oDuration -= oMicroseconds;
		auto oNanoseconds	= std::chrono::duration_cast< std::chrono::nanoseconds >( oDuration );

		ImU64 const uNanoSecondsCountRaw	= oNanoseconds.count();
		ImU64 const uNanoSecondsCount		= uNanoSecondsCountRaw <= 100ull ? 0ull : uNanoSecondsCountRaw;

		sResult.clear();
		if ( oDays.count() > 0 )
		{
			sResult =	std::to_string( oDays.count() )			+ " d : " +
						std::to_string( oHours.count() )		+ " h : " +
						std::to_string( oMinutes.count() )		+ " min : " +
						std::to_string( oSeconds.count() )		+ " s : " +
						std::to_string( oMilliseconds.count() )	+ " ms : " +
						//std::to_string( oMicroseconds.count() ) + " \u00B5s : " +
						std::to_string( oMicroseconds.count() ) + " us";//: " +
						//std::to_string( uNanoSecondsCount )		+ " ns";
		}
		else if ( oHours.count() > 0 )
		{
			sResult =	std::to_string( oHours.count() )		+ " h : " +
						std::to_string( oMinutes.count() )		+ " min : " +
						std::to_string( oSeconds.count() )		+ " s : " +
						std::to_string( oMilliseconds.count() )	+ " ms : " +
						//std::to_string( oMicroseconds.count() ) + " \u00B5s : " +
						std::to_string( oMicroseconds.count() ) + " us";//: " +
						//std::to_string( uNanoSecondsCount )		+ " ns";
		}
		else if ( oMinutes.count() > 0 )
		{
			sResult =	std::to_string( oMinutes.count() )		+ " min : " +
						std::to_string( oSeconds.count() )		+ " s : " +
						std::to_string( oMilliseconds.count() )	+ " ms : " +
						//std::to_string( oMicroseconds.count() ) + " \u00B5s : " +
						std::to_string( oMicroseconds.count() ) + " us";//: " +
						//std::to_string( uNanoSecondsCount )		+ " ns";
		}
		else if ( oSeconds.count() > 0 )
		{
			sResult =	std::to_string( oSeconds.count() )		+ " s : " +
						std::to_string( oMilliseconds.count() )	+ " ms : " +
						//std::to_string( oMicroseconds.count() ) + " \u00B5s : " +
						std::to_string( oMicroseconds.count() ) + " us";//: " +
						//std::to_string( uNanoSecondsCount )		+ " ns";
		}
		else if ( oMilliseconds.count() > 0 )
		{
			sResult =	std::to_string( oMilliseconds.count() )	+ " ms : " +
						//std::to_string( oMicroseconds.count() ) + " \u00B5s : " +
						std::to_string( oMicroseconds.count() ) + " us";//: " +
						//std::to_string( uNanoSecondsCount )		+ " ns";
		}
		else if ( oMicroseconds.count() > 0 )
		{
			sResult =	//std::to_string( oMicroseconds.count() ) + " \u00B5s : " +
						std::to_string( oMicroseconds.count() ) + " us";//: " +
						//std::to_string( uNanoSecondsCount )		+ " ns";
		}
		else //if ( oNanoseconds.count() > 0 )
		{
			sResult =	std::to_string( uNanoSecondsCount )		+ " ns";
		}
	}

	float Dist2(ImVec2 const v, ImVec2 const w)
	{
		//return Sqr(v.x - w.x) + Sqr(v.y - w.y);
		return ImLengthSqr(v - w);
	}
	float DistOnSegmentSqr(ImVec2 const p, ImVec2 const v, ImVec2 const w)
	{
		float l2 = Dist2(v, w);
		if (l2 == 0.0f)
			return 0.0f;

		float t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;

		return ImSaturate(t) * Dist2(w, v);
	}
	float DistToSegmentSqr(ImVec2 const p, ImVec2 const v, ImVec2 const w)
	{
		float l2 = Dist2(v, w);
		if (l2 == 0.0f)
			return Dist2(p, v);

		float t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
		t = ImSaturate(t);

		return Dist2(p, ImVec2(v.x + t * (w.x - v.x),
							   v.y + t * (w.y - v.y)));
	}
	float Side(ImVec2 const src, ImVec2 const tgt, ImVec2 const pts)
	{
		ImVec2 vDir = tgt - src;
		ImVec2 vVec = pts - src;

		float zCross = vDir.x * vVec.y - vDir.y * vVec.x;

		return zCross >= 0.0f ? 1.0f : -1.0f;
	}
	ImVec2 Saturatev(ImVec2 const v)
	{
		return ImVec2(ImSaturate(v.x), ImSaturate(v.y));
	}
	ImVec2 Clampv(ImVec2 const v, ImVec2 const min, ImVec2 const max)
	{
		return ImVec2(ImClamp(v.x, min.x, max.x), ImClamp(v.y, min.y, max.y));
	}
	float Rescale01(float const x, float const min, float const max)
	{
		return (x - min) / (max - min);
	}
	ImVec2 Rescale01v(ImVec2 const v, ImVec2 const min, ImVec2 const max)
	{
		return ImVec2(Rescale01(v.x, min.x, max.x), Rescale01(v.y, min.y, max.y));
	}
	float Rescale(float const x, float const min, float const max, float const newMin, float const newMax)
	{
		return Rescale01(x, min, max) * (newMax - newMin) + newMin;
	}
	ImVec2 Rescalev(ImVec2 const x, ImVec2 const min, ImVec2 const max, ImVec2 const newMin, ImVec2 const newMax)
	{
		ImVec2 const vNorm = Rescale01v(x, min, max);
		return ImVec2(vNorm.x * (newMax.x - newMin.x) + newMin.x, vNorm.y * (newMax.y - newMin.y) + newMin.y);
	}
	float Sign(float x)
	{
		return x < 0.0f ? -1.0f : 1.0f;
	}

	//////////////////////////////////////////////////////////////////////////
	// Widgets
	//////////////////////////////////////////////////////////////////////////
	void CenterNextItem(ImVec2 nextItemSize)
	{
		float const width = ImGui::GetContentRegionAvailWidth();
		ImGui::Dummy(ImVec2((width - nextItemSize.x) * 0.5f, nextItemSize.y));
		ImGui::SameLine();
	}

	bool DragFloatLog(const char* label, float* data, float v_speed, float log_basis, const void* p_min, const void* p_max, ImGuiSliderFlags flags)
	{
		ImGuiWindow* window = ImGui::GetCurrentWindow();
		if (window->SkipItems)
			return false;

		ImGuiContext& g = *GImGui;
		const ImGuiStyle& style = g.Style;
		const ImGuiID id = window->GetID(label);
		const float w = ImGui::CalcItemWidth();
		const ImVec2 label_size = ImGui::CalcTextSize(label, NULL, true);
		const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));
		const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

		ImGui::ItemSize(total_bb, style.FramePadding.y);
		if (!ImGui::ItemAdd(total_bb, id, &frame_bb))
			return false;

		//// Default format string when passing NULL
		//if (format == NULL)
		//	format = ImGui::DataTypeGetInfo(data_type)->PrintFmt;
		//else if (data_type == ImGuiDataType_S32 && strcmp(format, "%d") != 0) // (FIXME-LEGACY: Patch old "%.0f" format string to use "%d", read function more details.)
		//	format = ImGui::PatchFormatStringFloatToInt(format);

		// Tabbing or CTRL-clicking on Drag turns it into an InputText
		const bool hovered = ImGui::ItemHoverable(frame_bb, id);
		const bool temp_input_allowed = (flags & ImGuiSliderFlags_NoInput) == 0;
		bool temp_input_is_active = temp_input_allowed && ImGui::TempInputIsActive(id);
		if (!temp_input_is_active)
		{
			const bool focus_requested = temp_input_allowed && ImGui::FocusableItemRegister(window, id);
			const bool clicked = (hovered && g.IO.MouseClicked[0]);
			const bool double_clicked = (hovered && g.IO.MouseDoubleClicked[0]);
			if (focus_requested || clicked || double_clicked || g.NavActivateId == id || g.NavInputId == id)
			{
				ImGui::SetActiveID(id, window);
				ImGui::SetFocusID(id, window);
				ImGui::FocusWindow(window);
				g.ActiveIdUsingNavDirMask = (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);
				if (temp_input_allowed && (focus_requested || (clicked && g.IO.KeyCtrl) || double_clicked || g.NavInputId == id))
				{
					temp_input_is_active = true;
					ImGui::FocusableItemUnregister(window);
				}
			}
			// Experimental: simple click (without moving) turns Drag into an InputText
			// FIXME: Currently polling ImGuiConfigFlags_IsTouchScreen, may either poll an hypothetical ImGuiBackendFlags_HasKeyboard and/or an explicit drag settings.
			if (g.IO.ConfigDragClickToInputText && temp_input_allowed && !temp_input_is_active)
				if (g.ActiveId == id && hovered && g.IO.MouseReleased[0] && !ImGui::IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * 0.5f/*DRAG_MOUSE_THRESHOLD_FACTOR*/))
				{
					g.NavInputId = id;
					temp_input_is_active = true;
					ImGui::FocusableItemUnregister(window);
				}
		}

		if (temp_input_is_active)
		{
			// Only clamp CTRL+Click input when ImGuiSliderFlags_AlwaysClamp is set
			const bool is_clamp_input = (flags & ImGuiSliderFlags_AlwaysClamp) != 0 && (p_min == NULL || p_max == NULL || ImGui::DataTypeCompare(ImGuiDataType_Float, p_min, p_max) < 0);
			return ImGui::TempInputScalar(frame_bb, id, label, ImGuiDataType_Float, data, "%f", is_clamp_input ? p_min : NULL, is_clamp_input ? p_max : NULL);
		}

		// Draw frame
		const ImU32 frame_col = ImGui::GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
		ImGui::RenderNavHighlight(frame_bb, id);
		ImGui::RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding);

		// Drag behavior
		const bool value_changed = ImGui::DragBehavior(id, ImGuiDataType_Float, data, v_speed, p_min, p_max, "%f", flags);
		if (value_changed)
			ImGui::MarkItemEdited(id);

		// Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
		char value_buf[64];
		const char* value_buf_end = value_buf + ImGui::DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), ImGuiDataType_Float, data, "%f");
		if (g.LogEnabled)
			ImGui::LogSetNextTextDecoration("{", "}");
		ImGui::RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.5f));

		if (label_size.x > 0.0f)
			ImGui::RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

		IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags);
		return value_changed;
	}

	bool DragLengthScalar(const char* label, ImGuiDataType data_type, void* p_data, ImWidgetsLengthUnit* p_defaultUnit, float v_speed, const void* p_min, const void* p_max, ImGuiSliderFlags flags)
	{
		bool modified = false;

		ImWidgetsLengthUnit& defaultUnit = *p_defaultUnit;

		std::string format = std::string(ImGui::DataTypeGetInfo(data_type)->PrintFmt);
		if (ImGui::Button("<", ImVec2(16.0f, 0.0f)))
		{
			--defaultUnit;
			if (defaultUnit < 0)
				defaultUnit = ImWidgetsLengthUnit_COUNT - 1;
		}
		ImGui::SameLine();
		if (defaultUnit == ImWidgetsLengthUnit_Imperial)
		{
			ScaleData(data_type, p_data, 0.28084);
			format += " ft";
		}
		else
		{
			format += " m";
		}
		float const width = ImGui::GetContentRegionAvailWidth();
		ImGui::SetNextItemWidth(width * 0.5f - 32.0f);
		modified |= ImGui::DragScalar(label, data_type, p_data, v_speed, p_min, p_max, format.c_str(), flags);
		if (defaultUnit == ImWidgetsLengthUnit_Imperial)
		{
			ScaleData(data_type, p_data, 1.0 / 0.28084);
		}
		ImGui::SameLine();
		if (ImGui::Button(">", ImVec2(16.0f, 0.0f)))
		{
			++defaultUnit;
			defaultUnit %= ImWidgetsLengthUnit_COUNT;
		}
		ImGui::SetWindowFontScale(1.0f);
		ImVec2 const vTextSize = ImGui::CalcTextSize(defaultUnit == ImWidgetsLengthUnit_Metric ? "meter" : "feet");
		CenterNextItem(vTextSize);
		ImGui::Text(defaultUnit == ImWidgetsLengthUnit_Metric ? "meter" : "feet");
		ImGui::SetWindowFontScale(1.0f);

		return modified;
	}

	bool InputVec2(char const* pLabel, ImVec2* pValue, ImVec2* p_vMinValue, ImVec2* p_vMaxValue, float const fScale /*= 1.0f*/)
	{
		return Slider2DScalar(pLabel, ImGuiDataType_Float, &pValue->x, &pValue->y, &p_vMinValue->x, &p_vMaxValue->x, &p_vMinValue->y, &p_vMaxValue->y, fScale);
	}

	bool InputVec3(char const* pLabel, ImVec4* pValue, ImVec4 const vMinValue, ImVec4 const vMaxValue, float const fScale /*= 1.0f*/)
	{
		return SliderScalar3D(pLabel, &pValue->x, &pValue->y, &pValue->z, vMinValue.x, vMaxValue.x, vMinValue.y, vMaxValue.y, vMinValue.z, vMaxValue.z, fScale);
	}

	bool Slider2DScalar(char const* pLabel, ImGuiDataType data_type, void* p_valueX, void* p_valueY, void* p_minX, void* p_maxX, void* p_minY, void* p_maxY, float const fScale /*= 1.0f*/)
	{
		assert(ScalarToFloat(data_type, (ImU64*)p_minX) < ScalarToFloat(data_type, (ImU64*)p_maxX));
		assert(ScalarToFloat(data_type, (ImU64*)p_minY) < ScalarToFloat(data_type, (ImU64*)p_maxY));

		ImGuiWindow* window = ImGui::GetCurrentWindow();
		if (window->SkipItems)
			return false;

		//ImGuiContext& g = *GImGui;
		//const ImGuiStyle& style = g.Style;
		//const ImGuiID id = window->GetID(pLabel);

		ImGuiID const iID = ImGui::GetID(pLabel);

		ImVec2 const vSizeSubstract = ImGui::CalcTextSize(std::to_string(1.0f).c_str()) * 1.1f;

		float const vSizeFull = (ImGui::GetWindowContentRegionWidth() - vSizeSubstract.x) * fScale;
		ImVec2 const vSize(vSizeFull, vSizeFull);

		float const fHeightOffset = ImGui::GetTextLineHeight();
		ImVec2 const vHeightOffset(0.0f, fHeightOffset);

		ImVec2 vPos = ImGui::GetCursorScreenPos();
		ImRect oRect(vPos + vHeightOffset, vPos + vSize + vHeightOffset);

		ImGui::Text(pLabel);

		ImGui::PushID(iID);

		ImU32 const uFrameCol = ImGui::GetColorU32(ImGuiCol_FrameBg);

		ImVec2 const vOriginPos = ImGui::GetCursorScreenPos();
		ImGui::RenderFrame(oRect.Min, oRect.Max, uFrameCol, false, 0.0f);

		ImU64 s_delta_x = SubScalar(data_type, p_maxX, p_minX);
		ImU64 s_delta_y = SubScalar(data_type, p_maxY, p_minY);

		bool bModified = false;
		ImVec2 const vSecurity(15.0f, 15.0f);
		ImRect frame_bb = ImRect(oRect.Min - vSecurity, oRect.Max + vSecurity);
		//ImGui::PushItemFlag(ImGuiItemFlags_NoNav, true);
		bool hovered;
		bool held;
		bool pressed = ImGui::ButtonBehavior(frame_bb, ImGui::GetID("##Zone"), &hovered, &held);
		if (hovered && held)
		{
			ImVec2 const vCursorPos = ImGui::GetMousePos() - oRect.Min;

			float fValueX = vCursorPos.x / (oRect.Max.x - oRect.Min.x) * ScalarToFloat(data_type, &s_delta_x) + ScalarToFloat(data_type, (ImU64*)p_minX);
			float fValueY = ScalarToFloat(data_type, &s_delta_y) - vCursorPos.y / (oRect.Max.y - oRect.Min.y) * ScalarToFloat(data_type, &s_delta_y) + ScalarToFloat(data_type, (ImU64*)p_minY);

			ImU64 s_value_x = FloatToScalar(data_type, fValueX);
			ImU64 s_value_y = FloatToScalar(data_type, fValueY);

			EqualScalar(data_type, (ImU64*)p_valueX, &s_value_x);
			EqualScalar(data_type, (ImU64*)p_valueY, &s_value_y);

			bModified = true;
		}
		//ImGui::PopItemFlag();

		ImU64 s_clamped_x = ClampScalar(data_type, p_valueX, p_minX, p_maxX);
		ImU64 s_clamped_y = ClampScalar(data_type, p_valueY, p_minY, p_maxY);
		EqualScalar(data_type, (ImU64*)p_valueX, &s_clamped_x);
		EqualScalar(data_type, (ImU64*)p_valueY, &s_clamped_y);

		float const fScaleX = (ScalarToFloat(data_type, (ImU64*)p_valueX) - ScalarToFloat(data_type, (ImU64*)p_minX)) / ScalarToFloat(data_type, &s_delta_x);
		float const fScaleY = 1.0f - (ScalarToFloat(data_type, (ImU64*)p_valueY) - ScalarToFloat(data_type, (ImU64*)p_minY)) / ScalarToFloat(data_type, &s_delta_y);

		constexpr float fCursorOff = 10.0f;
		float const fXLimit = fCursorOff / oRect.GetWidth();
		float const fYLimit = fCursorOff / oRect.GetHeight();

		ImVec2 const vCursorPos((oRect.Max.x - oRect.Min.x) * fScaleX + oRect.Min.x, (oRect.Max.y - oRect.Min.y) * fScaleY + oRect.Min.y);

		ImDrawList* pDrawList = ImGui::GetWindowDrawList();

		ImVec4 const vBlue(70.0f / 255.0f, 102.0f / 255.0f, 230.0f / 255.0f, 1.0f); // TODO: choose from style
		ImVec4 const vOrange(255.0f / 255.0f, 128.0f / 255.0f, 64.0f / 255.0f, 1.0f); // TODO: choose from style

		ImS32 const uBlue = ImGui::GetColorU32(vBlue);
		ImS32 const uOrange = ImGui::GetColorU32(vOrange);

		constexpr float fBorderThickness	= 2.0f;
		constexpr float fLineThickness		= 3.0f;
		constexpr float fHandleRadius		= 7.0f;
		constexpr float fHandleOffsetCoef	= 2.0f;

		// Cursor
		pDrawList->AddCircleFilled(vCursorPos, 5.0f, uBlue, 16);

		// Vertical Line
		if (fScaleY > 2.0f * fYLimit)
			pDrawList->AddLine(ImVec2(vCursorPos.x, oRect.Min.y + fCursorOff), ImVec2(vCursorPos.x, vCursorPos.y - fCursorOff), uOrange, fLineThickness);
		if (fScaleY < 1.0f - 2.0f * fYLimit)
			pDrawList->AddLine(ImVec2(vCursorPos.x, oRect.Max.y - fCursorOff), ImVec2(vCursorPos.x, vCursorPos.y + fCursorOff), uOrange, fLineThickness);

		// Horizontal Line
		if (fScaleX > 2.0f * fXLimit)
			pDrawList->AddLine(ImVec2(oRect.Min.x + fCursorOff, vCursorPos.y), ImVec2(vCursorPos.x - fCursorOff, vCursorPos.y), uOrange, fLineThickness);
		if (fScaleX < 1.0f - 2.0f * fYLimit)
			pDrawList->AddLine(ImVec2(oRect.Max.x - fCursorOff, vCursorPos.y), ImVec2(vCursorPos.x + fCursorOff, vCursorPos.y), uOrange, fLineThickness);

		std::string formatX = ImGui::DataTypeGetInfo(data_type)->PrintFmt;
		std::string formatY = ImGui::DataTypeGetInfo(data_type)->PrintFmt;

		if (IsPositiveScalar(data_type, (ImU64*)p_valueX))
		{
			formatX = " " + formatX;
		}
		if (IsPositiveScalar(data_type, (ImU64*)p_valueY))
		{
			formatY = " " + formatY;
		}

		char pBufferX[64];
		char pBufferY[64];
		/*const char* value_buf_end_x = pBufferX + */ImGui::DataTypeFormatString(pBufferX, IM_ARRAYSIZE(pBufferX), data_type, p_valueX, formatX.c_str());
		/*const char* value_buf_end_y = pBufferX + */ImGui::DataTypeFormatString(pBufferY, IM_ARRAYSIZE(pBufferY), data_type, p_valueY, formatY.c_str());

		ImU32 const uTextCol = ImGui::ColorConvertFloat4ToU32(ImGui::GetStyle().Colors[ImGuiCol_Text]);

		ImGui::SetWindowFontScale(0.75f);

		ImVec2 const vXSize = ImGui::CalcTextSize(pBufferX);
		ImVec2 const vYSize = ImGui::CalcTextSize(pBufferY);

		ImVec2 const vHandlePosX = ImVec2(vCursorPos.x, oRect.Max.y + vYSize.x * 0.5f);
		ImVec2 const vHandlePosY = ImVec2(oRect.Max.x + fHandleOffsetCoef * fCursorOff + vYSize.x, vCursorPos.y);

		ImRect handle_x_bb = ImRect(vHandlePosX - ImVec2(fHandleRadius, fHandleRadius) - vSecurity, vHandlePosX + ImVec2(fHandleRadius, fHandleRadius) + vSecurity);
		ImRect handle_y_bb = ImRect(vHandlePosY - ImVec2(fHandleRadius, fHandleRadius) - vSecurity, vHandlePosY + ImVec2(fHandleRadius, fHandleRadius) + vSecurity);
		pressed = ImGui::ButtonBehavior(handle_x_bb, ImGui::GetID("##HandleX"), &hovered, &held);
		if (hovered && held)
		{
			ImVec2 const vCursorPosLocal = ImGui::GetMousePos() - oRect.Min;

			//*fValueX = vCursorPos.x / (oRect.Max.x - oRect.Min.x) * fDeltaX + fMinX;
			float fValueX = vCursorPosLocal.x / (oRect.Max.x - oRect.Min.x) * ScalarToFloat(data_type, &s_delta_x) + ScalarToFloat(data_type, (ImU64*)p_minX);
			ImU64 s_value_x = FloatToScalar(data_type, fValueX);
			EqualScalar(data_type, (ImU64*)p_valueX, &s_value_x);

			bModified = true;
		}
		pressed = ImGui::ButtonBehavior(handle_y_bb, ImGui::GetID("##HandleX"), &hovered, &held);
		if (hovered && held)
		{
			ImVec2 const vCursorPosLocal = ImGui::GetMousePos() - oRect.Min;

			//*fValueY = fDeltaY - vCursorPos.y / (oRect.Max.y - oRect.Min.y) * fDeltaY + fMinY;
			float fValueY = ScalarToFloat(data_type, &s_delta_y) - vCursorPosLocal.y / (oRect.Max.y - oRect.Min.y) * ScalarToFloat(data_type, &s_delta_y) + ScalarToFloat(data_type, (ImU64*)p_minY);
			ImU64 s_value_y = FloatToScalar(data_type, fValueY);
			EqualScalar(data_type, (ImU64*)p_valueY, &s_value_y);

			bModified = true;
		}

		pDrawList->AddText(
			ImVec2(
				ImMin(ImMax(vCursorPos.x - vXSize.x * 0.5f, oRect.Min.x), oRect.Min.x + vSize.x - vXSize.x),
				oRect.Max.y + fCursorOff),
			uTextCol,
			pBufferX);
		pDrawList->AddText(
			ImVec2(oRect.Max.x + fCursorOff, ImMin(ImMax(vCursorPos.y - vYSize.y * 0.5f, oRect.Min.y),
				oRect.Min.y + vSize.y - vYSize.y)),
			uTextCol,
			pBufferY);
		ImGui::SetWindowFontScale(1.0f);

		// Borders::Right
		pDrawList->AddCircleFilled(ImVec2(oRect.Max.x, vCursorPos.y), 2.0f, uOrange, 3);
		// Handle Right::Y
		pDrawList->AddNgonFilled(ImVec2(oRect.Max.x + fHandleOffsetCoef * fCursorOff + vYSize.x, vCursorPos.y), fHandleRadius, uBlue, 4);
		if (fScaleY > fYLimit)
			pDrawList->AddLine(ImVec2(oRect.Max.x, oRect.Min.y), ImVec2(oRect.Max.x, vCursorPos.y - fCursorOff), uBlue, fBorderThickness);
		if (fScaleY < 1.0f - fYLimit)
			pDrawList->AddLine(ImVec2(oRect.Max.x, oRect.Max.y), ImVec2(oRect.Max.x, vCursorPos.y + fCursorOff), uBlue, fBorderThickness);
		// Borders::Top
		pDrawList->AddCircleFilled(ImVec2(vCursorPos.x, oRect.Min.y), 2.0f, uOrange, 3);
		if (fScaleX > fXLimit)
			pDrawList->AddLine(ImVec2(oRect.Min.x, oRect.Min.y), ImVec2(vCursorPos.x - fCursorOff, oRect.Min.y), uBlue, fBorderThickness);
		if (fScaleX < 1.0f - fXLimit)
			pDrawList->AddLine(ImVec2(oRect.Max.x, oRect.Min.y), ImVec2(vCursorPos.x + fCursorOff, oRect.Min.y), uBlue, fBorderThickness);
		// Borders::Left
		pDrawList->AddCircleFilled(ImVec2(oRect.Min.x, vCursorPos.y), 2.0f, uOrange, 3);
		if (fScaleY > fYLimit)
			pDrawList->AddLine(ImVec2(oRect.Min.x, oRect.Min.y), ImVec2(oRect.Min.x, vCursorPos.y - fCursorOff), uBlue, fBorderThickness);
		if (fScaleY < 1.0f - fYLimit)
			pDrawList->AddLine(ImVec2(oRect.Min.x, oRect.Max.y), ImVec2(oRect.Min.x, vCursorPos.y + fCursorOff), uBlue, fBorderThickness);
		// Borders::Bottom
		pDrawList->AddCircleFilled(ImVec2(vCursorPos.x, oRect.Max.y), 2.0f, uOrange, 3);
		// Handle Bottom::X
		pDrawList->AddNgonFilled(ImVec2(vCursorPos.x, oRect.Max.y + vXSize.y * 2.0f), fHandleRadius, uBlue, 4);
		if (fScaleX > fXLimit)
			pDrawList->AddLine(ImVec2(oRect.Min.x, oRect.Max.y), ImVec2(vCursorPos.x - fCursorOff, oRect.Max.y), uBlue, fBorderThickness);
		if (fScaleX < 1.0f - fXLimit)
			pDrawList->AddLine(ImVec2(oRect.Max.x, oRect.Max.y), ImVec2(vCursorPos.x + fCursorOff, oRect.Max.y), uBlue, fBorderThickness);

		ImGui::PopID();

		ImGui::Dummy(vHeightOffset);
		ImGui::Dummy(vHeightOffset);
		ImGui::Dummy(vSize);

		return bModified;
	}

	bool Slider2DInt(char const* pLabel, int* pValueX, int* pValueY, int* p_minX, int* p_maxX, int* p_minY, int* p_maxY, float const fScale)
	{
		return Slider2DScalar(pLabel, ImGuiDataType_S32, pValueX, pValueY, p_minX, p_maxX, p_minY, p_maxY, fScale);
	}

	bool Slider2DFloat(char const* pLabel, float* pValueX, float* pValueY, float* p_minX, float* p_maxX, float* p_minY, float* p_maxY, float const fScale)
	{
		return Slider2DScalar(pLabel, ImGuiDataType_Float, pValueX, pValueY, p_minX, p_maxX, p_minY, p_maxY, fScale);
	}

	bool Slider2DDouble(char const* pLabel, double* pValueX, double* pValueY, double* p_minX, double* p_maxX, double* p_minY, double* p_maxY, float const fScale)
	{
		return Slider2DScalar(pLabel, ImGuiDataType_Double, pValueX, pValueY, p_minX, p_maxX, p_minY, p_maxY, fScale);
	}

	bool SliderScalar3D(char const* pLabel, float* pValueX, float* pValueY, float* pValueZ, float const fMinX, float const fMaxX, float const fMinY, float const fMaxY, float const fMinZ, float const fMaxZ, float const fScale /*= 1.0f*/)
	{
		assert(fMinX < fMaxX);
		assert(fMinY < fMaxY);
		assert(fMinZ < fMaxZ);

		ImGuiID const iID = ImGui::GetID(pLabel);

		ImVec2 const vSizeSubstract = ImGui::CalcTextSize(std::to_string(1.0f).c_str()) * 1.1f;

		float const vSizeFull = ImGui::GetWindowContentRegionWidth();
		float const fMinSize = (vSizeFull - vSizeSubstract.x * 0.5f) * fScale * 0.75f;
		ImVec2 const vSize(fMinSize, fMinSize);

		float const fHeightOffset = ImGui::GetTextLineHeight();
		ImVec2 const vHeightOffset(0.0f, fHeightOffset);

		ImVec2 vPos = ImGui::GetCursorScreenPos();
		ImRect oRect(vPos + vHeightOffset, vPos + vSize + vHeightOffset);

		ImGui::Text(pLabel);

		ImGui::PushID(iID);

		ImU32 const uFrameCol = ImGui::GetColorU32(ImGuiCol_FrameBg) | 0xFF000000;
		ImU32 const uFrameCol2 = ImGui::GetColorU32(ImGuiCol_FrameBgActive);

		float& fX = *pValueX;
		float& fY = *pValueY;
		float& fZ = *pValueZ;

		float const fDeltaX = fMaxX - fMinX;
		float const fDeltaY = fMaxY - fMinY;
		float const fDeltaZ = fMaxZ - fMinZ;

		ImVec2 const vOriginPos = ImGui::GetCursorScreenPos();

		ImDrawList* pDrawList = ImGui::GetWindowDrawList();

		float const fX3 = vSize.x / 3.0f;
		float const fY3 = vSize.y / 3.0f;

		ImVec2 const vStart = oRect.Min;

		ImVec2 aPositions[] = {
			ImVec2(vStart.x,			vStart.y + fX3),
			ImVec2(vStart.x,			vStart.y + vSize.y),
			ImVec2(vStart.x + 2.0f * fX3,	vStart.y + vSize.y),
			ImVec2(vStart.x + vSize.x,	vStart.y + 2.0f * fY3),
			ImVec2(vStart.x + vSize.x,	vStart.y),
			ImVec2(vStart.x + fX3,		vStart.y)
		};

		pDrawList->AddPolyline(&aPositions[0], 6, uFrameCol2, true, 1.0f);

		// Cube Shape
		pDrawList->AddLine(
			oRect.Min + ImVec2(0.0f, vSize.y),
			oRect.Min + ImVec2(fX3, 2.0f * fY3), uFrameCol2, 1.0f);
		pDrawList->AddLine(
			oRect.Min + ImVec2(fX3, 2.0f * fY3),
			oRect.Min + ImVec2(vSize.x, 2.0f * fY3), uFrameCol2, 1.0f);
		pDrawList->AddLine(
			oRect.Min + ImVec2(fX3, 0.0f),
			oRect.Min + ImVec2(fX3, 2.0f * fY3), uFrameCol2, 1.0f);

		ImGui::PopID();

		constexpr float fDragZOffsetX = 64.0f;

		ImRect oZDragRect(ImVec2(vStart.x + 2.0f * fX3 + fDragZOffsetX, vStart.y + 2.0f * fY3), ImVec2(vStart.x + vSize.x + fDragZOffsetX, vStart.y + vSize.y));

		ImVec2 const vMousePos = ImGui::GetMousePos();
		ImVec2 const vSecurity(15.0f, 15.0f);
		ImVec2 const vDragStart(oZDragRect.Min.x, oZDragRect.Max.y);
		ImVec2 const vDragEnd(oZDragRect.Max.x, oZDragRect.Min.y);
		ImRect frame_bb = ImRect(oRect.Min - vSecurity, oRect.Max + vSecurity);
		bool bModified = false;
		bool hovered;
		bool held;
		bool pressed = ImGui::ButtonBehavior(oZDragRect, ImGui::GetID("##HandleZ"), &hovered, &held);
		if (hovered && held)
		{
			if (DistToSegmentSqr(vMousePos, vDragStart, vDragEnd) < 100.0f) // 100 is arbitrary threshold
			{
				float const fMaxDist = ImSqrt(Dist2(vDragStart, vDragEnd));
				float const fDist = ImSaturate(ImSqrt(DistOnSegmentSqr(vMousePos, vDragStart, vDragEnd)) / fMaxDist);

				fZ = fDist * fDeltaZ * fDist + fMinZ;

				bModified = true;
			}
		}

		float const fScaleZ = (fZ - fMinZ) / fDeltaZ;

		ImVec2 const vRectStart(vStart.x, vStart.y + fX3);
		ImVec2 const vRectEnd(vStart.x + fX3, vStart.y);
		ImRect const oXYDrag((vRectEnd - vRectStart) * fScaleZ + vRectStart,
							 (vRectEnd - vRectStart) * fScaleZ + vRectStart + ImVec2(2.0f * fX3, 2.0f * fY3));
		//if (ImGui::IsMouseHoveringRect(oXYDrag.Min - vSecurity, oXYDrag.Max + vSecurity) && ImGui::IsMouseDown(ImGuiMouseButton_Left))
		pressed = ImGui::ButtonBehavior(oXYDrag, ImGui::GetID("##Zone"), &hovered, &held);
		if (hovered && held)
		{
			ImVec2 const vLocalPos = ImGui::GetMousePos() - oXYDrag.Min;

			fX = vLocalPos.x / (oXYDrag.Max.x - oXYDrag.Min.x) * fDeltaX + fMinX;
			fY = fDeltaY - vLocalPos.y / (oXYDrag.Max.y - oXYDrag.Min.y) * fDeltaY + fMinY;

			bModified = true;
		}

		fX = ImClamp(fX, fMinX, fMaxX);
		fY = ImClamp(fY, fMinY, fMaxY);
		fZ = ImClamp(fZ, fMinZ, fMaxZ);

		float const fScaleX = (fX - fMinX) / fDeltaX;
		float const fScaleY = 1.0f - (fY - fMinY) / fDeltaY;

		ImVec4 const vBlue(70.0f / 255.0f, 102.0f / 255.0f, 230.0f / 255.0f, 1.0f);
		ImVec4 const vOrange(255.0f / 255.0f, 128.0f / 255.0f, 64.0f / 255.0f, 1.0f);

		ImS32 const uBlue = ImGui::GetColorU32(vBlue);
		ImS32 const uOrange = ImGui::GetColorU32(vOrange);

		constexpr float fBorderThickness = 2.0f; // TODO: move as Style
		constexpr float fLineThickness = 3.0f; // TODO: move as Style
		constexpr float fHandleRadius = 7.0f; // TODO: move as Style
		constexpr float fHandleOffsetCoef = 2.0f; // TODO: move as Style

		pDrawList->AddLine(
			vDragStart,
			vDragEnd, uFrameCol2, 1.0f);
		pDrawList->AddRectFilled(
			oXYDrag.Min, oXYDrag.Max, uFrameCol);

		constexpr float fCursorOff = 10.0f;
		float const fXLimit = fCursorOff / oXYDrag.GetWidth();
		float const fYLimit = fCursorOff / oXYDrag.GetHeight();
		float const fZLimit = fCursorOff / oXYDrag.GetWidth();

		char pBufferX[16];
		char pBufferY[16];
		char pBufferZ[16];
		ImFormatString(pBufferX, IM_ARRAYSIZE(pBufferX), "%.5f", *(float const*)& fX);
		ImFormatString(pBufferY, IM_ARRAYSIZE(pBufferY), "%.5f", *(float const*)& fY);
		ImFormatString(pBufferZ, IM_ARRAYSIZE(pBufferZ), "%.5f", *(float const*)& fZ);

		ImU32 const uTextCol = ImGui::ColorConvertFloat4ToU32(ImGui::GetStyle().Colors[ImGuiCol_Text]);

		ImVec2 const vCursorPos((oXYDrag.Max.x - oXYDrag.Min.x) * fScaleX + oXYDrag.Min.x, (oXYDrag.Max.y - oXYDrag.Min.y) * fScaleY + oXYDrag.Min.y);

		ImGui::SetWindowFontScale(0.75f);

		ImVec2 const vXSize = ImGui::CalcTextSize(pBufferX);
		ImVec2 const vYSize = ImGui::CalcTextSize(pBufferY);
		ImVec2 const vZSize = ImGui::CalcTextSize(pBufferZ);

		ImVec2 const vTextSlideXMin = oRect.Min + ImVec2(0.0f, vSize.y);
		ImVec2 const vTextSlideXMax = oRect.Min + ImVec2(2.0f * fX3, vSize.y);
		ImVec2 const vXTextPos((vTextSlideXMax - vTextSlideXMin) * fScaleX + vTextSlideXMin);

		ImVec2 const vTextSlideYMin = oRect.Min + ImVec2(vSize.x, 2.0f * fY3);
		ImVec2 const vTextSlideYMax = oRect.Min + ImVec2(vSize.x, 0.0f);
		ImVec2 const vYTextPos((vTextSlideYMax - vTextSlideYMin) * (1.0f - fScaleY) + vTextSlideYMin);

		ImVec2 const vTextSlideZMin = vDragStart + ImVec2(fCursorOff, fCursorOff);
		ImVec2 const vTextSlideZMax = vDragEnd + ImVec2(fCursorOff, fCursorOff);
		ImVec2 const vZTextPos((vTextSlideZMax - vTextSlideZMin) * fScaleZ + vTextSlideZMin);

		ImVec2 const vHandlePosX = vXTextPos + ImVec2(0.0f, vXSize.y + fHandleOffsetCoef * fCursorOff);
		ImVec2 const vHandlePosY = vYTextPos + ImVec2(vYSize.x + (fHandleOffsetCoef + 1.0f) * fCursorOff, 0.0f);

		ImRect handle_x_bb = ImRect(vHandlePosX - ImVec2(fHandleRadius, fHandleRadius) - vSecurity, vHandlePosX + ImVec2(fHandleRadius, fHandleRadius) + vSecurity);
		ImRect handle_y_bb = ImRect(vHandlePosY - ImVec2(fHandleRadius, fHandleRadius) - vSecurity, vHandlePosY + ImVec2(fHandleRadius, fHandleRadius) + vSecurity);
		//ImRect handle_z_bb = ImRect(vHandlePosY - ImVec2(fHandleRadius, fHandleRadius) - vSecurity, vHandlePosY + ImVec2(fHandleRadius, fHandleRadius) + vSecurity);

		//if (ImGui::IsMouseHoveringRect(vHandlePosX - ImVec2(fHandleRadius, fHandleRadius) - vSecurity, vHandlePosX + ImVec2(fHandleRadius, fHandleRadius) + vSecurity) &&
		//	ImGui::IsMouseDown(ImGuiMouseButton_Left))
		pressed = ImGui::ButtonBehavior(handle_x_bb, ImGui::GetID("##HandleX"), &hovered, &held);
		if (hovered && held)
		{
			float const fCursorPosX = ImGui::GetMousePos().x - vStart.x;

			fX = fDeltaX * fCursorPosX / (2.0f * fX3) + fMinX;

			bModified = true;
		}
		//else if (ImGui::IsMouseHoveringRect(vHandlePosY - ImVec2(fHandleRadius, fHandleRadius) - vSecurity, vHandlePosY + ImVec2(fHandleRadius, fHandleRadius) + vSecurity) &&
		//	ImGui::IsMouseDown(ImGuiMouseButton_Left))
		pressed = ImGui::ButtonBehavior(handle_y_bb, ImGui::GetID("##HandleY"), &hovered, &held);
		if (hovered && held)
		{
			float const fCursorPosY = ImGui::GetMousePos().y - vStart.y;

			fY = fDeltaY * (1.0f - fCursorPosY / (2.0f * fY3)) + fMinY;

			bModified = true;
		}

		pDrawList->AddText(
			ImVec2(
				ImMin(ImMax(vXTextPos.x - vXSize.x * 0.5f, vTextSlideXMin.x), vTextSlideXMax.x - vXSize.x),
				vXTextPos.y + fCursorOff),
			uTextCol,
			pBufferX);
		pDrawList->AddText(
			ImVec2(
				vYTextPos.x + fCursorOff,
				ImMin(ImMax(vYTextPos.y - vYSize.y * 0.5f, vTextSlideYMax.y), vTextSlideYMin.y - vYSize.y)),
			uTextCol,
			pBufferY);
		pDrawList->AddText(
			vZTextPos,
			uTextCol,
			pBufferZ);
		ImGui::SetWindowFontScale(1.0f);

		// Handles
		pDrawList->AddNgonFilled(vHandlePosX, fHandleRadius, uBlue, 4);
		pDrawList->AddNgonFilled(vHandlePosY, fHandleRadius, uBlue, 4);

		// Vertical Line
		if (fScaleY > 2.0f * fYLimit)
			pDrawList->AddLine(ImVec2(vCursorPos.x, oXYDrag.Min.y + fCursorOff), ImVec2(vCursorPos.x, vCursorPos.y - fCursorOff), uOrange, fLineThickness);
		if (fScaleY < 1.0f - 2.0f * fYLimit)
			pDrawList->AddLine(ImVec2(vCursorPos.x, oXYDrag.Max.y - fCursorOff), ImVec2(vCursorPos.x, vCursorPos.y + fCursorOff), uOrange, fLineThickness);

		// Horizontal Line
		if (fScaleX > 2.0f * fXLimit)
			pDrawList->AddLine(ImVec2(oXYDrag.Min.x + fCursorOff, vCursorPos.y), ImVec2(vCursorPos.x - fCursorOff, vCursorPos.y), uOrange, fLineThickness);
		if (fScaleX < 1.0f - 2.0f * fYLimit)
			pDrawList->AddLine(ImVec2(oXYDrag.Max.x - fCursorOff, vCursorPos.y), ImVec2(vCursorPos.x + fCursorOff, vCursorPos.y), uOrange, fLineThickness);

		// Line To Text
		// X
		if (fScaleZ > 2.0f * fZLimit)
			pDrawList->AddLine(
				ImVec2(vCursorPos.x - 0.5f * fCursorOff, oXYDrag.Max.y + 0.5f * fCursorOff),
				ImVec2(vXTextPos.x + 0.5f * fCursorOff, vXTextPos.y - 0.5f * fCursorOff), uOrange, fLineThickness
			);
		else
			pDrawList->AddLine(
				ImVec2(vCursorPos.x, oXYDrag.Max.y),
				ImVec2(vXTextPos.x, vXTextPos.y), uOrange, 1.0f
			);
		pDrawList->AddCircleFilled(vXTextPos, 2.0f, uOrange, 3);
		// Y
		if (fScaleZ < 1.0f - 2.0f * fZLimit)
			pDrawList->AddLine(
				ImVec2(oXYDrag.Max.x + 0.5f * fCursorOff, vCursorPos.y - 0.5f * fCursorOff),
				ImVec2(vYTextPos.x - 0.5f * fCursorOff, vYTextPos.y + 0.5f * fCursorOff), uOrange, fLineThickness
			);
		else
			pDrawList->AddLine(
				ImVec2(oXYDrag.Max.x, vCursorPos.y),
				ImVec2(vYTextPos.x, vYTextPos.y), uOrange, 1.0f
			);
		pDrawList->AddCircleFilled(vYTextPos, 2.0f, uOrange, 3);

		// Borders::Right
		pDrawList->AddCircleFilled(ImVec2(oXYDrag.Max.x, vCursorPos.y), 2.0f, uOrange, 3);
		if (fScaleY > fYLimit)
			pDrawList->AddLine(ImVec2(oXYDrag.Max.x, oXYDrag.Min.y), ImVec2(oXYDrag.Max.x, vCursorPos.y - fCursorOff), uBlue, fBorderThickness);
		if (fScaleY < 1.0f - fYLimit)
			pDrawList->AddLine(ImVec2(oXYDrag.Max.x, oXYDrag.Max.y), ImVec2(oXYDrag.Max.x, vCursorPos.y + fCursorOff), uBlue, fBorderThickness);
		// Borders::Top
		pDrawList->AddCircleFilled(ImVec2(vCursorPos.x, oXYDrag.Min.y), 2.0f, uOrange, 3);
		if (fScaleX > fXLimit)
			pDrawList->AddLine(ImVec2(oXYDrag.Min.x, oXYDrag.Min.y), ImVec2(vCursorPos.x - fCursorOff, oXYDrag.Min.y), uBlue, fBorderThickness);
		if (fScaleX < 1.0f - fXLimit)
			pDrawList->AddLine(ImVec2(oXYDrag.Max.x, oXYDrag.Min.y), ImVec2(vCursorPos.x + fCursorOff, oXYDrag.Min.y), uBlue, fBorderThickness);
		// Borders::Left
		pDrawList->AddCircleFilled(ImVec2(oXYDrag.Min.x, vCursorPos.y), 2.0f, uOrange, 3);
		if (fScaleY > fYLimit)
			pDrawList->AddLine(ImVec2(oXYDrag.Min.x, oXYDrag.Min.y), ImVec2(oXYDrag.Min.x, vCursorPos.y - fCursorOff), uBlue, fBorderThickness);
		if (fScaleY < 1.0f - fYLimit)
			pDrawList->AddLine(ImVec2(oXYDrag.Min.x, oXYDrag.Max.y), ImVec2(oXYDrag.Min.x, vCursorPos.y + fCursorOff), uBlue, fBorderThickness);
		// Borders::Bottom
		pDrawList->AddCircleFilled(ImVec2(vCursorPos.x, oXYDrag.Max.y), 2.0f, uOrange, 3);
		if (fScaleX > fXLimit)
			pDrawList->AddLine(ImVec2(oXYDrag.Min.x, oXYDrag.Max.y), ImVec2(vCursorPos.x - fCursorOff, oXYDrag.Max.y), uBlue, fBorderThickness);
		if (fScaleX < 1.0f - fXLimit)
			pDrawList->AddLine(ImVec2(oXYDrag.Max.x, oXYDrag.Max.y), ImVec2(vCursorPos.x + fCursorOff, oXYDrag.Max.y), uBlue, fBorderThickness);

		pDrawList->AddLine(
			oRect.Min + ImVec2(0.0f, fY3),
			oRect.Min + ImVec2(2.0f * fX3, fY3), uFrameCol2, 1.0f);
		pDrawList->AddLine(
			oRect.Min + ImVec2(2.0f * fX3, fY3),
			oRect.Min + ImVec2(vSize.x, 0.0f), uFrameCol2, 1.0f);
		pDrawList->AddLine(
			oRect.Min + ImVec2(2.0f * fX3, fY3),
			oRect.Min + ImVec2(2.0f * fX3, vSize.y), uFrameCol2, 1.0f);

		// Cursor
		pDrawList->AddCircleFilled(vCursorPos, 5.0f, uBlue, 16);
		// CursorZ
		pDrawList->AddNgonFilled((vDragEnd - vDragStart) * fScaleZ + vDragStart, fHandleRadius, uBlue, 4);

		ImGui::Dummy(vHeightOffset);
		ImGui::Dummy(vHeightOffset * 1.25f);
		ImGui::Dummy(vSize);

		return bModified;
	}

	bool Grid2D_AoS_Float(const char* label, float* buffer, int rows, int columns, float minX, float maxX, float minY, float maxY)
	{
		assert(minX < maxX);
		assert(minY < maxY);

		ImGuiID const iID = ImGui::GetID(label);
		ImGui::PushID(iID);

		float const vSizeFull = ImGui::GetWindowContentRegionWidth();
		ImVec2 const vSecurity(15.0f, 15.0f);
		ImVec2 const vSize(vSizeFull - vSecurity.x, vSizeFull - vSecurity.y);

		float const fHeightOffset = ImGui::GetTextLineHeight();
		ImVec2 const vHeightOffset(0.0f, fHeightOffset);

		ImVec2 vPos = ImGui::GetCursorScreenPos();
		ImRect oRect(vPos + vSecurity, vPos + vSize);

		float const width = oRect.GetWidth();
		float const height = oRect.GetHeight();

		//ImGui::InvisibleButton("##Zone", oRect.GetSize(), 0);
		ImGui::Dummy(oRect.GetSize());

		bool hovered;
		bool held;

		ImDrawList* pDrawList = ImGui::GetWindowDrawList();
		// Horizontal Line
		for (int j = 0; j < rows; ++j)
		{
			for (int i = 0; i < columns - 1; ++i)
			{
				float x0 = buffer[2 * ((j + 0) * columns + i + 0) + 0];
				float y0 = buffer[2 * ((j + 0) * columns + i + 0) + 1];
				float x1 = buffer[2 * ((j + 0) * columns + i + 1) + 0];
				float y1 = buffer[2 * ((j + 0) * columns + i + 1) + 1];

				pDrawList->AddLine(oRect.GetTL() + ImVec2(x0 * width, y0 * height), oRect.GetTL() + ImVec2(x1 * width, y1 * height), IM_COL32(255, 255, 0, 255), 2.0f);
			}
		}
		// Vertical Line
		for (int j = 0; j < rows - 1; ++j)
		{
			for (int i = 0; i < columns; ++i)
			{
				float x0 = buffer[2 * ((j + 0) * columns + i + 0) + 0];
				float y0 = buffer[2 * ((j + 0) * columns + i + 0) + 1];
				float x1 = buffer[2 * ((j + 1) * columns + i + 0) + 0];
				float y1 = buffer[2 * ((j + 1) * columns + i + 0) + 1];

				pDrawList->AddLine(oRect.GetTL() + ImVec2(x0 * width, y0 * height), oRect.GetTL() + ImVec2(x1 * width, y1 * height), IM_COL32(255, 255, 0, 255), 2.0f);
			}
		}
		for (int j = 0; j < rows; ++j)
		{
			for (int i = 0; i < columns; ++i)
			{
				float* pX = &buffer[2 * (j * columns + i) + 0];
				float* pY = &buffer[2 * (j * columns + i) + 1];

				ImVec2 vCenter = oRect.GetTL() + ImVec2(*pX * width, *pY * height);
				ImRect oLocalRect(vCenter - oRect.GetSize() * 0.01f, vCenter + oRect.GetSize() * 0.01f);

				ImGui::PushID(pX);

				ImGui::ButtonBehavior(oLocalRect, ImGui::GetID(pY), &hovered, &held);
				bool dragged = hovered && held;
				pDrawList->AddCircleFilled(vCenter, vSize.x * 0.01f, IM_COL32(hovered ? 0 : 255, hovered ? 255 : 0, 0, 255), 16);
				if (dragged)
				{
					ImVec2 vCursorPos = ImGui::GetMousePos();
					ImVec2 vDelta = vCursorPos - oLocalRect.GetCenter();

					vDelta /= oRect.GetSize();

					*pX += vDelta.x;
					*pY += vDelta.y;

					*pX = ImSaturate(*pX);
					*pY = ImSaturate(*pY);
				}

				ImGui::PopID();
			}
		}

		ImGui::Dummy(ImVec2(ImGui::GetContentRegionAvailWidth(), ImGui::GetTextLineHeightWithSpacing()));

		ImGui::PopID();

		return false;
	}

	bool PlaneMovePoint2D(const char* label, float* buffer_aot, int float2_count, float minX, float maxX, float minY, float maxY)
	{
		assert(minX < maxX);
		assert(minY < maxY);

		ImGuiID const iID = ImGui::GetID(label);
		ImGui::PushID(iID);

		float const vSizeFull = ImGui::GetWindowContentRegionWidth();
		ImVec2 const vSecurity(15.0f, 15.0f);
		ImVec2 const vSize(vSizeFull - vSecurity.x, vSizeFull - vSecurity.y);

		float const fHeightOffset = ImGui::GetTextLineHeight();
		ImVec2 const vHeightOffset(0.0f, fHeightOffset);

		ImVec2 vPos = ImGui::GetCursorScreenPos();
		ImRect oRect(vPos + vSecurity, vPos + vSize);

		float const width = oRect.GetWidth();
		float const height = oRect.GetHeight();

		//ImGui::InvisibleButton("##Zone", oRect.GetSize(), 0);
		ImGui::Dummy(oRect.GetSize());

		bool hovered;
		bool held;

		ImDrawList* pDrawList = ImGui::GetWindowDrawList();
		for (int i = 0; i < float2_count; ++i)
		{
			float* pX = &buffer_aot[2 * i + 0];
			float* pY = &buffer_aot[2 * i + 1];

			ImVec2 vCenter = oRect.GetTL() + ImVec2(*pX * width, *pY * height);
			ImRect oLocalRect(vCenter - oRect.GetSize() * 0.01f, vCenter + oRect.GetSize() * 0.01f);

			ImGui::PushID(pX);

			ImGui::ButtonBehavior(oLocalRect, ImGui::GetID(pY), &hovered, &held);
			bool dragged = hovered && held;
			pDrawList->AddCircleFilled(vCenter, vSize.x * 0.01f, IM_COL32(hovered ? 0 : 255, hovered ? 255 : 0, 0, 255), 16);
			if (dragged)
			{
				ImVec2 vCursorPos = ImGui::GetMousePos();
				ImVec2 vDelta = vCursorPos - oLocalRect.GetCenter();

				vDelta /= oRect.GetSize();

				*pX += vDelta.x;
				*pY += vDelta.y;

				*pX = ImSaturate(*pX);
				*pY = ImSaturate(*pY);
			}

			ImGui::PopID();
		}

		ImGui::Dummy(ImVec2(ImGui::GetContentRegionAvailWidth(), ImGui::GetTextLineHeightWithSpacing()));

		ImGui::PopID();

		return false;
	}

	IMGUI_API bool MoveLine2D(const char* label, float* buffer_aot, int float2_count, float minX, float maxX, float minY, float maxY)
	{
		assert(minX < maxX);
		assert(minY < maxY);

		bool modified = false;

		ImGuiID const iID = ImGui::GetID(label);
		ImGui::PushID(iID);

		float const vSizeFull = ImGui::GetWindowContentRegionWidth();
		ImVec2 const vSecurity(15.0f, 15.0f);
		ImVec2 const vSize(vSizeFull - vSecurity.x, vSizeFull - vSecurity.y);

		float const fHeightOffset = ImGui::GetTextLineHeight();
		ImVec2 const vHeightOffset(0.0f, fHeightOffset);

		ImVec2 vPos = ImGui::GetCursorScreenPos();
		ImRect oRect(vPos + vSecurity, vPos + vSize);

		float const width = oRect.GetWidth();
		float const height = oRect.GetHeight();

		ImGui::Dummy(oRect.GetSize());

		ImDrawList* pDrawList = ImGui::GetWindowDrawList();
		//pDrawList->AddBezierCurve()
		//pDrawList->AddPolyline(reinterpret_cast<ImVec2*>(buffer_aot), float2_count, IM_COL32(255, 255, 0, 255), false, 2.0f);
		pDrawList->PathClear();
		for (int i = 0; i < float2_count - 1; ++i)
		{
			float x0 = Rescale(buffer_aot[2 * (i + 0) + 0], minX, maxX, 0.0f, 1.0f);
			float y0 = Rescale(buffer_aot[2 * (i + 0) + 1], minY, maxY, 0.0f, 1.0f);
			float x1 = Rescale(buffer_aot[2 * (i + 1) + 0], minX, maxX, 0.0f, 1.0f);
			float y1 = Rescale(buffer_aot[2 * (i + 1) + 1], minY, maxY, 0.0f, 1.0f);

			pDrawList->AddLine(oRect.GetTL() + ImVec2(x0 * width, y0 * height), oRect.GetTL() + ImVec2(x1 * width, y1 * height), IM_COL32(255, 255, 0, 255), 2.0f);
		}
		//for (int i = 0; i < float2_count - 1; ++i)
		//{
		//	float x0 = Rescale(buffer_aot[2 * (i + 0) + 0], minX, maxX, 0.0f, 1.0f);
		//	float y0 = Rescale(buffer_aot[2 * (i + 0) + 1], minY, maxY, 0.0f, 1.0f);
		//	float x1 = Rescale(buffer_aot[2 * (i + 1) + 0], minX, maxX, 0.0f, 1.0f);
		//	float y1 = Rescale(buffer_aot[2 * (i + 1) + 1], minY, maxY, 0.0f, 1.0f);
		//
		//	pDrawList->AddLine(oRect.GetTL() + ImVec2(x0 * width, y0 * height), oRect.GetTL() + ImVec2(x1 * width, y1 * height), IM_COL32(255, 255, 0, 255), 2.0f);
		//}

		bool hovered;
		bool held;
		for (int i = 0; i < float2_count; ++i)
		{
			float* pX = &buffer_aot[2 * i + 0];
			float* pY = &buffer_aot[2 * i + 1];

			float x = Rescale(*pX, minX, maxX, 0.0f, 1.0f);
			float y = Rescale(*pY, minY, maxY, 0.0f, 1.0f);

			ImVec2 vCenter = oRect.GetTL() + ImVec2(x * width, y * height);
			ImRect oLocalRect(vCenter - oRect.GetSize() * 0.01f, vCenter + oRect.GetSize() * 0.01f);

			ImGui::PushID(pX);

			ImGui::ButtonBehavior(oLocalRect, ImGui::GetID(pY), &hovered, &held);
			bool dragged = hovered && held;
			pDrawList->AddCircleFilled(vCenter, vSize.x * 0.01f, IM_COL32(hovered ? 0 : 255, hovered ? 255 : 0, 0, 255), 16);
			if (dragged)
			{
				ImVec2 vCursorPos = ImGui::GetMousePos();
				ImVec2 vDelta = vCursorPos - oLocalRect.GetCenter();

				vDelta /= oRect.GetSize();

				*pX += vDelta.x;
				*pY += vDelta.y;

				*pX = ImClamp(*pX, minX, maxX);
				*pY = ImClamp(*pY, minY, maxY);

				modified = true;
			}

			ImGui::PopID();
		}

		if (modified)
		{
			ImVec2* pVec2Buffer = reinterpret_cast<ImVec2*>(buffer_aot);

			std::sort(	pVec2Buffer, pVec2Buffer + float2_count,
						[]( ImVec2 const& a, ImVec2 const& b)
						{
							return a.x < b.x;
						});
		}

		ImGui::Dummy(ImVec2(ImGui::GetContentRegionAvailWidth(), ImGui::GetTextLineHeightWithSpacing()));

		ImGui::PopID();

		return modified;
	}

	bool HueToHue(const char* label)
	{
		ImGuiID const iID = ImGui::GetID(label);
		ImGui::PushID(iID);

		ImVec2 curPos = ImGui::GetCursorScreenPos();
		float const width = ImGui::GetContentRegionAvailWidth();
		float const height = 0.5f * width;

		//const float window_rounding = ImGui::GetStyle().WindowRounding;
		//ImGui::RenderFrame(curPos, curPos + ImVec2(width, width));
		ImGui::InvisibleButton("##Zone", ImVec2(width, height), 0);

		ImVec2 uv_white = ImGui::GetFontTexUvWhitePixel();

		float dx = width / 6.0f;

		ImVec2 x00(curPos + ImVec2(0, 0));
		//ImVec2 x01(curPos + ImVec2(0, height));
		ImVec2 x02(curPos + ImVec2(dx, 0));
		ImVec2 x03(curPos + ImVec2(dx, height));
		ImVec2 x04(curPos + ImVec2(2*dx, 0));
		ImVec2 x05(curPos + ImVec2(2*dx, height));
		ImVec2 x06(curPos + ImVec2(3*dx, 0));
		ImVec2 x07(curPos + ImVec2(3*dx, height));
		ImVec2 x08(curPos + ImVec2(4*dx, 0));
		ImVec2 x09(curPos + ImVec2(4*dx, height));
		ImVec2 x10(curPos + ImVec2(5*dx, 0));
		ImVec2 x11(curPos + ImVec2(5*dx, height));
		//ImVec2 x12(curPos + ImVec2(6*dx, 0));
		ImVec2 x13(curPos + ImVec2(6*dx, height));

		ImU32 const alpha = 64;
		ImU32 const red		= IM_COL32(255, 0, 0, alpha);
		ImU32 const yellow	= IM_COL32(255, 255, 0, alpha);
		ImU32 const green	= IM_COL32(0, 255, 0, alpha);
		ImU32 const cyan	= IM_COL32(0, 255, 255, alpha);
		ImU32 const blue	= IM_COL32(0, 0, 255, alpha);
		ImU32 const magenta	= IM_COL32(255, 0, 255, alpha);

		ImDrawList* pDrawList = ImGui::GetWindowDrawList();
		pDrawList->AddRectFilledMultiColor(x00, x03, red, yellow, yellow, red);
		pDrawList->AddRectFilledMultiColor(x02, x05, yellow, green, green, yellow);
		pDrawList->AddRectFilledMultiColor(x04, x07, green, cyan, cyan, green);
		pDrawList->AddRectFilledMultiColor(x06, x09, cyan, blue, blue, cyan);
		pDrawList->AddRectFilledMultiColor(x08, x11, blue, magenta, magenta, blue);
		pDrawList->AddRectFilledMultiColor(x10, x13, magenta, red, red, magenta);

		ImGui::PopID();

		return false;
	}

	bool LumToSat(const char* label)
	{
		ImGuiID const iID = ImGui::GetID(label);
		ImGui::PushID(iID);

		ImVec2 curPos = ImGui::GetCursorScreenPos();
		float const width = ImGui::GetContentRegionAvailWidth();
		float const height = 0.5f * width;

		ImGui::InvisibleButton("##Zone", ImVec2(width, height), 0);

		const int slice = 32;
		const float fSlice = static_cast<float>(slice);

		ImVec2 dA(curPos);
		ImVec2 dB(curPos + ImVec2(width / fSlice, height));

		ImVec2 const dD(ImVec2(width / fSlice, 0));

		ImU32 const alpha	= 255;

		ImDrawList* pDrawList = ImGui::GetWindowDrawList();
		for (int i = 0; i < slice; ++i)
		{
			float t0 = ((float)i) / ((float)(slice - 1));
			float t1 = ((float)(i + 1)) / ((float)(slice - 1));

			ImU8 u0 = static_cast<ImU8>(ImPow(ImSaturate(t0), 2.2f) * 255);
			ImU8 u1 = static_cast<ImU8>(ImPow(ImSaturate(t1), 2.2f) * 255);

			ImU32 const col0 = IM_COL32(u0, u0, u0, alpha);
			ImU32 const col1 = IM_COL32(u1, u1, u1, alpha);
			pDrawList->AddRectFilledMultiColor(dA, dB, col0, col1, col1, col0);

			dA += dD;
			dB += dD;
		}
		//ImGui::ShadeVertsLinearColorGradientKeepAlpha(pDrawList, vert_start_idx, vert_end_idx, x00, x12, black, white);

		ImGui::PopID();

		return false;
	}

	bool ColorRing(const char* label, float thickness, int split)
	{
		ImGuiID const iID = ImGui::GetID(label);
		ImGui::PushID(iID);

		ImVec2 curPos = ImGui::GetCursorScreenPos();
		float const width = ImGui::GetContentRegionAvailWidth();
		float const height = width;

		ImGui::InvisibleButton("##Zone", ImVec2(width, height), 0);

		//int vrtxCount = split * 6;
		//int triCount = split * 2;

		float radius = width * 0.5f; // minus 2*padding

		const float dAngle = 2.0f * IM_PI / ((float)split);
		float angle = 2.0f * IM_PI / 3.0f;

		ImVec2 offset = curPos + ImVec2(radius, radius);

		ImVec2 const uv = ImGui::GetFontTexUvWhitePixel();
		ImDrawList* pDrawList = ImGui::GetWindowDrawList();
		pDrawList->PrimReserve(split * 6, split * 4);
		for (int i = 0; i < split; ++i)
		{
			float x0 = radius * ImCos(angle);
			float y0 = radius * ImSin(angle);

			float x1 = radius * ImCos(angle + dAngle);
			float y1 = radius * ImSin(angle + dAngle);

			float x2 = (radius - thickness) * ImCos(angle + dAngle);
			float y2 = (radius - thickness) * ImSin(angle + dAngle);

			float x3 = (radius - thickness) * ImCos(angle);
			float y3 = (radius - thickness) * ImSin(angle);

			pDrawList->PrimWriteIdx((ImDrawIdx)(pDrawList->_VtxCurrentIdx));
			pDrawList->PrimWriteIdx((ImDrawIdx)(pDrawList->_VtxCurrentIdx + 1));
			pDrawList->PrimWriteIdx((ImDrawIdx)(pDrawList->_VtxCurrentIdx + 2));

			pDrawList->PrimWriteIdx((ImDrawIdx)(pDrawList->_VtxCurrentIdx));
			pDrawList->PrimWriteIdx((ImDrawIdx)(pDrawList->_VtxCurrentIdx + 2));
			pDrawList->PrimWriteIdx((ImDrawIdx)(pDrawList->_VtxCurrentIdx + 3));

			float r0, g0, b0;
			float r1, g1, b1;
			ImGui::ColorConvertHSVtoRGB(((float)i) / ((float)(split - 1)), 1.0f, 1.0f, r0, g0, b0);
			ImGui::ColorConvertHSVtoRGB(((float)((i + 1)%split)) / ((float)(split - 1)), 1.0f, 1.0f, r1, g1, b1);

			pDrawList->PrimWriteVtx(offset + ImVec2(x0, y0), uv, IM_COL32(r0 * 255, g0 * 255, b0 * 255, 255));
			pDrawList->PrimWriteVtx(offset + ImVec2(x1, y1), uv, IM_COL32(r1 * 255, g1 * 255, b1 * 255, 255));
			pDrawList->PrimWriteVtx(offset + ImVec2(x2, y2), uv, IM_COL32(r1 * 255, g1 * 255, b1 * 255, 255));
			pDrawList->PrimWriteVtx(offset + ImVec2(x3, y3), uv, IM_COL32(r0 * 255, g0 * 255, b0 * 255, 255));
			angle += dAngle;
		}
		ImGui::PopID();

		return false;
	}

	float	FunctionFromData(float const x, float const minX, float const maxX, float* data, int const samples_count)
	{
		float const t = ImSaturate(Normalize01(x, minX, maxX));

		return LinearSample(t, data, samples_count);
	}

	ImU32	ImColorFrom_xyz(float x, float y, float z, float* xyzToRGB, float gamma)
	{
		float r, g, b;
		float maxValue;
		Mat33MulV(&r, &g, &b, x, y, z, xyzToRGB);
		maxValue = ImMax(r, ImMax(g, b));
		if (maxValue > 0.0f)
		{
			r /= maxValue;
			g /= maxValue;
			b /= maxValue;
		}
		r = ImSaturate(r);
		g = ImSaturate(g);
		b = ImSaturate(b);

		r = ImPow(r, gamma);
		g = ImPow(g, gamma);
		b = ImPow(b, gamma);

		return IM_COL32(r * 255, g * 255, b * 255, 255);
	}

	static ImVec2 s_ChromaticPlotStart = ImVec2(0.0f, 0.0f);
	static ImVec2 s_ChromaticPlotSize = ImVec2(128.0f, 128.0f);
	static ImVec2 s_ChromaticPlotBoundMin = ImVec2(0.0f, 0.8f);
	static ImVec2 s_ChromaticPlotBoundMax = ImVec2(0.0f, 0.9f);

	template <bool IsBilinear>
	void	ChromaticPlotInternalCommon(ImDrawList* pDrawList,
		ImVec2 const curPos,
		float width, float height,
		ImVec2 primR, ImVec2 primG, ImVec2 primB,
		ImVec2 whitePoint,
		float* xyzToRGB,
		int const chromeLineSamplesCount,
		float* observerX, float* observerY, float* observerZ,
		int const observerSampleCount,
		float const observerWavelengthMin, float const observerWavelengthMax,
		float* standardCIE,
		int const standardCIESampleCount,
		float const standardCIEWavelengthMin, float const standardCIEWavelengthMax,
		float gamma,
		int resX, int resY,
		float wavelengthMin, float wavelengthMax,
		float minX, float maxX,
		float minY, float maxY)
	{
		ImVec2 const uv = ImGui::GetFontTexUvWhitePixel();

		float sx = ((float)width) / ((float)resX);
		float sy = ((float)height) / ((float)resY);
		float dx = 0.5f * sx;
		float dy = 0.5f * sx;
		// From x: 0 -> 0.8; y: 0 -> 0.9
		float r, g, b;
		float maxValue;
		for (int i = 0; i < resX; ++i)
		{
			float x0 = ScaleFromNormalized(((float)(i + 0)) / ((float)(resX - 1)), minX, maxX);
			float x1 = ScaleFromNormalized(((float)(i + 1)) / ((float)(resX - 1)), minX, maxX);

			for (int j = 0; j < resY; ++j)
			{
				float y0 = ScaleFromNormalized(1.0f - ((float)(j + 0)) / ((float)(resY - 1)), minY, maxY);
				float y1 = ScaleFromNormalized(1.0f - ((float)(j + 1)) / ((float)(resY - 1)), minY, maxY);
				float z00 = 1.0f - x0 - y0;
				float z10 = 1.0f - x1 - y0;
				float z01 = 1.0f - x0 - y1;
				float z11 = 1.0f - x1 - y1;

				ImU32 const col00 = ImColorFrom_xyz(x0, y0, z00, xyzToRGB, gamma);
				if constexpr (IsBilinear)
				{
					ImU32 const col01 = ImColorFrom_xyz(x0, y1, z01, xyzToRGB, gamma);
					ImU32 const col10 = ImColorFrom_xyz(x1, y0, z10, xyzToRGB, gamma);
					ImU32 const col11 = ImColorFrom_xyz(x1, y1, z11, xyzToRGB, gamma);

					pDrawList->AddRectFilledMultiColor(curPos + ImVec2(sx * (i + 0), sy * (j + 0)),
												   		curPos + ImVec2(sx * (i + 1), sy * (j + 1)),
												   		col00, col10, col11, col01);
				}
				else
				{
					pDrawList->AddRectFilledMultiColor(curPos + ImVec2(sx * (i + 0), sy * (j + 0)),
													   curPos + ImVec2(sx * (i + 1), sy * (j + 1)),
													   col00, col00, col00, col00);
				}
			}
		}

		int lineSamples = ImMin(chromeLineSamplesCount, observerSampleCount);

		float illum;
		float x, y, z;
		ImVector<ImVec2> chromLine;
		chromLine.resize(lineSamples);
		for (int i = 0; i < lineSamples; ++i)
		{
			float const wavelength = ScaleFromNormalized(1.0f - ((float)i) / ((float)(lineSamples - 1)), wavelengthMin, wavelengthMax);

			illum = FunctionFromData(wavelength, standardCIEWavelengthMin, standardCIEWavelengthMax, standardCIE, standardCIESampleCount);
			x = illum * FunctionFromData(wavelength, observerWavelengthMin, observerWavelengthMax, observerX, observerSampleCount);
			y = illum * FunctionFromData(wavelength, observerWavelengthMin, observerWavelengthMax, observerY, observerSampleCount);
			z = illum * FunctionFromData(wavelength, observerWavelengthMin, observerWavelengthMax, observerZ, observerSampleCount);

			float const sum = x + y + z;

			x /= sum;
			y /= sum;

			float xx = Rescale(x, minX, maxX, 0.0f, width);
			float yy = Rescale(y, maxY, minY, 0.0f, height);

			chromLine[i] = curPos + ImVec2(xx, yy);
		}

		DrawConvexMaskMesh(pDrawList, curPos, (float*)&chromLine[0], lineSamples, ImVec2(width, height));

		pDrawList->AddPolyline(&chromLine[0], lineSamples, IM_COL32(0, 0, 0, 255), true, 2.0f);

		ImVec2 sRGBLines[] = { primR, primG, primB };
		for (int i = 0; i < 3; ++i)
		{
			ImVec2& vCur = sRGBLines[i];

			vCur.x = curPos.x + Rescale(vCur.x, minX, maxX, 0.0f, width);
			vCur.y = curPos.y + Rescale(vCur.y, maxY, minY, 0.0f, height);
		}
		pDrawList->AddPolyline(&sRGBLines[0], 3, IM_COL32(255, 255, 255, 255), true, 5.0f);

		ImVec2 vWhitePoint = whitePoint;
		vWhitePoint.x = curPos.x + Rescale(vWhitePoint.x, minX, maxX, 0.0f, width);
		vWhitePoint.y = curPos.y + Rescale(vWhitePoint.y, maxY, minY, 0.0f, height);
		pDrawList->AddCircleFilled(vWhitePoint, 5.0f, IM_COL32(0, 0, 0, 255), 4);

		s_ChromaticPlotBoundMin = ImVec2(minX, minY);
		s_ChromaticPlotBoundMax = ImVec2(maxX, maxY);
		s_ChromaticPlotStart = curPos;
		s_ChromaticPlotSize = ImVec2(width, height);
	}

	void	DrawChromaticPlotNearest(ImDrawList* pDrawList,
		ImVec2 const vPos,
		float width, float height,
		int const chromeLineSamplesCount,
		ImWidgetsColorSpace const colorspace,
		ImWidgetsObserver const observer,
		ImWidgetsIlluminance const illum,
		int resX, int resY,
		float wavelengthMin, float wavelengthMax,
		float minX, float maxX,
		float minY, float maxY)
	{
		ChromaticPlotInternalCommon< false >(
			pDrawList,
			vPos,
			width, height,
			s_ColorSpace_Primaries[colorspace][0], s_ColorSpace_Primaries[colorspace][1], s_ColorSpace_Primaries[colorspace][2],
			s_WhitePoints_Values[s_ColorSpace_WhitePointIndex[colorspace]][illum],
			s_ColorSpace_XYZ2RGB[colorspace],
			chromeLineSamplesCount,
			s_CIE_Observers_X[observer], s_CIE_Observers_Y[observer], s_CIE_Observers_Z[observer],
			s_CIE_Observers_SamplesCount[observer],
			s_CIE_Observers_min[observer], s_CIE_Observers_max[observer],
			s_Illums[illum],
			s_Illums_SamplesCount[illum],
			s_Illums_min[illum], s_Illums_max[illum],
			1.0f / s_ColorSpace_Gamma[colorspace],
			resX, resY,
			wavelengthMin, wavelengthMax,
			minX, maxX,
			minY, maxY);
	}

	void	DrawChromaticPlotBilinear(ImDrawList* pDrawList,
		ImVec2 const vPos,
		float width, float height,
		int const chromeLineSamplesCount,
		ImWidgetsColorSpace const colorspace,
		ImWidgetsObserver const observer,
		ImWidgetsIlluminance const illum,
		int resX, int resY,
		float wavelengthMin, float wavelengthMax,
		float minX, float maxX,
		float minY, float maxY)
	{
		ChromaticPlotInternalCommon< true >(
			pDrawList,
			vPos,
			width, height,
			s_ColorSpace_Primaries[colorspace][0], s_ColorSpace_Primaries[colorspace][1], s_ColorSpace_Primaries[colorspace][2],
			s_WhitePoints_Values[s_ColorSpace_WhitePointIndex[colorspace]][illum],
			s_ColorSpace_XYZ2RGB[colorspace],
			chromeLineSamplesCount,
			s_CIE_Observers_X[observer], s_CIE_Observers_Y[observer], s_CIE_Observers_Z[observer],
			s_CIE_Observers_SamplesCount[observer],
			s_CIE_Observers_min[observer], s_CIE_Observers_max[observer],
			s_Illums[illum],
			s_Illums_SamplesCount[illum],
			s_Illums_min[illum], s_Illums_max[illum],
			1.0f / s_ColorSpace_Gamma[colorspace],
			resX, resY,
			wavelengthMin, wavelengthMax,
			minX, maxX,
			minY, maxY);
	}

	void DrawChromaticPoint(ImDrawList* pDrawList, ImVec2 const vpos, ImU32 col)
	{
		ImVec2 vPoint = vpos;
		vPoint.x = s_ChromaticPlotStart.x + Rescale(vPoint.x, s_ChromaticPlotBoundMin.x, s_ChromaticPlotBoundMax.x, 0.0f, s_ChromaticPlotSize.x);
		vPoint.y = s_ChromaticPlotStart.y + Rescale(vPoint.y, s_ChromaticPlotBoundMax.y, s_ChromaticPlotBoundMin.y, 0.0f, s_ChromaticPlotSize.y);
		pDrawList->AddCircleFilled(vPoint, 5.0f, col, 4);
	}

	IMGUI_API void DrawChromaticLine(ImDrawList* pDrawList, ImVec2 const* vpos, int const pts_counts, ImU32 col, bool closed, float thickness)
	{
		ImVector<ImVec2> pts;
		pts.resize(pts_counts);
		ImVec2 const* pCur = vpos;
		for (int i = 0; i < pts_counts; ++i)
		{
			ImVec2& vPoint = pts[i];
			vPoint.x = s_ChromaticPlotStart.x + Rescale(pCur->x, s_ChromaticPlotBoundMin.x, s_ChromaticPlotBoundMax.x, 0.0f, s_ChromaticPlotSize.x);
			vPoint.y = s_ChromaticPlotStart.y + Rescale(pCur->y, s_ChromaticPlotBoundMax.y, s_ChromaticPlotBoundMin.y, 0.0f, s_ChromaticPlotSize.y);

			++pCur;
		}
		pDrawList->AddPolyline(&pts[0], pts_counts, col, closed, thickness);
	}

	// Mask
	struct tri
	{
		ImU16 a; ImU16 b; ImU16 c;

		tri(ImU16 _a, ImU16 _b, ImU16 _c) :
			a(_a), b(_b), c(_c)
		{}
	};
#pragma optimize( "", off )
	void	DrawConvexMaskMesh(ImDrawList* pDrawList, ImVec2 curPos, float* buffer_aot, int float2_count, ImVec2 size)
	{
		//ImVec2 curPos = ImGui::GetCursorScreenPos();
		//float const width = ImGui::GetContentRegionAvailWidth();
		//float const height = width;

		//ImGui::InvisibleButton("##Zone", ImVec2(width, height), 0);

		//ImDrawList* pDrawList = ImGui::GetWindowDrawList();
		//ImDrawList* pDrawList = ImGui::GetOverlayDrawList();
		//ImDrawList* pDrawList = ImGui::GetBackgroundDrawList();

		ImVec2 bb_pts[4] = { curPos, curPos + ImVec2(0.0f, size.y), curPos + size, curPos + ImVec2(size.x, 0.0f) };

		// Get closer point compare to bb_min;
		float minDist = FLT_MAX;
		int foundIdx = -1;
		ImVec2* vBuffer = (ImVec2*)buffer_aot;
		//for (int i = float2_count - 1; i >= 0; --i)
		ImVec2* pCur = vBuffer;
		for (int i = 0; i < float2_count; ++i)
		{
			ImVec2 const& v = *pCur;
			++pCur;
			ImVec2 delta = v - curPos;
			float curDist = delta.x * delta.x + delta.y * delta.y;
			if (curDist < minDist)
			{
				minDist = curDist;
				foundIdx = i;
			}
		}

		// Generate triangles
		ImVector<tri> triangles;
		int boundIdx = 0;
		int curIdx = foundIdx;
		int nextIdx = foundIdx + 1;
		nextIdx %= float2_count;
		do
		{
			ImVec2& bnd = bb_pts[boundIdx];
			ImVec2 v0 = vBuffer[curIdx] - bnd;
			ImVec2 v1 = vBuffer[nextIdx] - bnd;
			v0 /= ImSqrt(ImLengthSqr(v0));
			v1 /= ImSqrt(ImLengthSqr(v1));
			float crossSign = ImSign(v0.x * v1.y - v0.y * v1.x);
			float dot = v0.x * v1.x + v0.y * v1.y;
			if (dot > 0.9999999f)
			{
				nextIdx++;
				nextIdx %= float2_count;
				continue;
			}
			if (crossSign > 0.0f)
			{
				triangles.push_back(tri(float2_count + boundIdx, nextIdx, curIdx));
				curIdx = nextIdx;
				nextIdx++;
				nextIdx %= float2_count;
			}
			else
			{
				int bnd2 = boundIdx + 1;
				bnd2 %= 4;
				triangles.push_back(tri(float2_count + boundIdx, float2_count + bnd2, curIdx));
				boundIdx = bnd2;
				triangles.push_back(tri(float2_count + boundIdx, nextIdx, curIdx));
				curIdx = nextIdx;
				nextIdx++;
				nextIdx %= float2_count;
			}
		} while (curIdx != foundIdx && nextIdx != ((foundIdx + 1) % float2_count));

		ImVec2 const uv = ImGui::GetFontTexUvWhitePixel();
		pDrawList->PrimReserve(triangles.size() * 3, float2_count + 4);

		for (tri const& tr : triangles)
		{
			pDrawList->PrimWriteIdx((ImDrawIdx)(pDrawList->_VtxCurrentIdx + tr.a));
			pDrawList->PrimWriteIdx((ImDrawIdx)(pDrawList->_VtxCurrentIdx + tr.b));
			pDrawList->PrimWriteIdx((ImDrawIdx)(pDrawList->_VtxCurrentIdx + tr.c));
		}

		//ImVec4 vBgCol = ImGui::GetStyle().Colors[ImGuiCol_FrameBg];
		ImVec4 vBgCol = ImGui::GetStyle().Colors[ImGuiCol_WindowBg];
		//vBgCol.w = 1.0f;
		ImU32 uBgCol = ImGui::ColorConvertFloat4ToU32(vBgCol);

		ImU32 const InColor = uBgCol;// IM_COL32(0, 0, 0, 255);
		ImU32 const OutColor = uBgCol;// IIM_COL32(0, 0, 0, 255);
		for (int i = 0; i < float2_count; ++i)
		{
			pDrawList->PrimWriteVtx(vBuffer[i], uv, InColor);
		}
		pDrawList->PrimWriteVtx(bb_pts[0], uv, OutColor);
		pDrawList->PrimWriteVtx(bb_pts[1], uv, OutColor);
		pDrawList->PrimWriteVtx(bb_pts[2], uv, OutColor);
		pDrawList->PrimWriteVtx(bb_pts[3], uv, OutColor);
	}

	// Density Plots
	template < bool IsBilinear >
	bool DensityPlotEx(const char* label, float(*sample)(float x, float y), int resX, int resY, float minX, float maxX, float minY, float maxY)
	{
		ImGuiID const iID = ImGui::GetID(label);
		ImGui::PushID(iID);

		float* pMin = ImGui::GetStateStorage()->GetFloatRef(iID + 0, FLT_MAX);
		float* pMax = ImGui::GetStateStorage()->GetFloatRef(iID + 1, -FLT_MAX);

		ImVec2 curPos = ImGui::GetCursorScreenPos();
		float const width = ImGui::GetContentRegionAvailWidth();
		float const height = width;

		ImGui::InvisibleButton("##Zone", ImVec2(width, height), 0);

		ImVec2 const uv = ImGui::GetFontTexUvWhitePixel();
		ImDrawList* pDrawList = ImGui::GetWindowDrawList();

		auto GetColor = [pMin, pMax, &sample](float x, float y) {
			float value = sample(x, y);
			if (value < *pMin)
				* pMin = value;
			if (value > * pMax)
				* pMax = value;

			float showValue = Normalize01(value, *pMin, *pMax);
			ImU32 const uVal = static_cast<ImU32>(showValue * 255.0f);

			return IM_COL32(uVal, uVal, uVal, 255);
		};

		float sx = ((float)width) / ((float)resX);
		float sy = ((float)height) / ((float)resY);
		float dx = 0.5f * sx;
		float dy = 0.5f * sx;
		// From x: 0 -> 0.8; y: 0 -> 0.9
		float r, g, b;
		float maxValue;
		for (int i = 0; i < resX; ++i)
		{
			float x0 = ScaleFromNormalized(((float)(i + 0)) / ((float)(resX - 1)), minX, maxX);
			float x1 = ScaleFromNormalized(((float)(i + 1)) / ((float)(resX - 1)), minX, maxX);

			for (int j = 0; j < resY; ++j)
			{
				float y0 = ScaleFromNormalized(1.0f - ((float)(j + 0)) / ((float)(resY - 1)), minY, maxY);
				float y1 = ScaleFromNormalized(1.0f - ((float)(j + 1)) / ((float)(resY - 1)), minY, maxY);

				ImU32 const col00 = GetColor(x0, y0);
				if constexpr (IsBilinear)
				{
					ImU32 const col01 = GetColor(x0, y1);
					ImU32 const col10 = GetColor(x1, y0);
					ImU32 const col11 = GetColor(x1, y1);
					pDrawList->AddRectFilledMultiColor(curPos + ImVec2(sx * (i + 0), sy * (j + 0)),
						curPos + ImVec2(sx * (i + 1), sy * (j + 1)),
						col00, col10, col11, col01);
				}
				else
				{
					pDrawList->AddRectFilledMultiColor(curPos + ImVec2(sx * (i + 0), sy * (j + 0)),
													   curPos + ImVec2(sx * (i + 1), sy * (j + 1)),
													   col00, col00, col00, col00);
				}
			}
		}

		ImGui::PopID();

		return false;
	}

	bool DensityPlotBilinear(const char* label, float(*sample)(float x, float y), int resX, int resY, float minX, float maxX, float minY, float maxY)
	{
		return DensityPlotEx<true>(label, sample, resX, resY, minX, maxX, minY, maxY);
	}
	bool DensityPlotNearest(const char* label, float(*sample)(float x, float y), int resX, int resY, float minX, float maxX, float minY, float maxY)
	{
		return DensityPlotEx<false>(label, sample, resX, resY, minX, maxX, minY, maxY);
	}


	//////////////////////////////////////////////////////////////////////////
	// External
	//////////////////////////////////////////////////////////////////////////
	static ImVector<ImRect> s_GroupPanelLabelStack;

	void BeginGroupPanel(const char* name, const ImVec2& size)
	{
		ImGui::BeginGroup();

		auto cursorPos = ImGui::GetCursorScreenPos();
		auto itemSpacing = ImGui::GetStyle().ItemSpacing;
		ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0.0f, 0.0f));
		ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));

		auto frameHeight = ImGui::GetFrameHeight();
		ImGui::BeginGroup();

		ImVec2 effectiveSize = size;
		if (size.x < 0.0f)
			effectiveSize.x = ImGui::GetContentRegionAvailWidth();
		else
			effectiveSize.x = size.x;
		ImGui::Dummy(ImVec2(effectiveSize.x, 0.0f));

		ImGui::Dummy(ImVec2(frameHeight * 0.5f, 0.0f));
		ImGui::SameLine(0.0f, 0.0f);
		ImGui::BeginGroup();
		ImGui::Dummy(ImVec2(frameHeight * 0.5f, 0.0f));
		ImGui::SameLine(0.0f, 0.0f);
		ImGui::TextUnformatted(name);
		auto labelMin = ImGui::GetItemRectMin();
		auto labelMax = ImGui::GetItemRectMax();
		ImGui::SameLine(0.0f, 0.0f);
		ImGui::Dummy(ImVec2(0.0, frameHeight + itemSpacing.y));
		ImGui::BeginGroup();

		//ImGui::GetWindowDrawList()->AddRect(labelMin, labelMax, IM_COL32(255, 0, 255, 255));

		ImGui::PopStyleVar(2);

#if IMGUI_VERSION_NUM >= 17301
		ImGui::GetCurrentWindow()->ContentRegionRect.Max.x -= frameHeight * 0.5f;
		ImGui::GetCurrentWindow()->WorkRect.Max.x -= frameHeight * 0.5f;
		ImGui::GetCurrentWindow()->InnerRect.Max.x -= frameHeight * 0.5f;
#else
		ImGui::GetCurrentWindow()->ContentsRegionRect.Max.x -= frameHeight * 0.5f;
#endif
		ImGui::GetCurrentWindow()->Size.x -= frameHeight;

		auto itemWidth = ImGui::CalcItemWidth();
		ImGui::PushItemWidth(ImMax(0.0f, itemWidth - frameHeight));

		s_GroupPanelLabelStack.push_back(ImRect(labelMin, labelMax));
	}

	void EndGroupPanel()
	{
		ImGui::PopItemWidth();

		auto itemSpacing = ImGui::GetStyle().ItemSpacing;

		ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0.0f, 0.0f));
		ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));

		auto frameHeight = ImGui::GetFrameHeight();

		ImGui::EndGroup();

		//ImGui::GetWindowDrawList()->AddRectFilled(ImGui::GetItemRectMin(), ImGui::GetItemRectMax(), IM_COL32(0, 255, 0, 64), 4.0f);

		ImGui::EndGroup();

		ImGui::SameLine(0.0f, 0.0f);
		ImGui::Dummy(ImVec2(frameHeight * 0.5f, 0.0f));
		ImGui::Dummy(ImVec2(0.0, frameHeight - frameHeight * 0.5f - itemSpacing.y));

		ImGui::EndGroup();

		auto itemMin = ImGui::GetItemRectMin();
		auto itemMax = ImGui::GetItemRectMax();
		//ImGui::GetWindowDrawList()->AddRectFilled(itemMin, itemMax, IM_COL32(255, 0, 0, 64), 4.0f);

		auto labelRect = s_GroupPanelLabelStack.back();
		s_GroupPanelLabelStack.pop_back();

		ImVec2 halfFrame = ImVec2(frameHeight * 0.25f, frameHeight) * 0.5f;
		ImRect frameRect = ImRect(itemMin + halfFrame, itemMax - ImVec2(halfFrame.x, 0.0f));
		labelRect.Min.x -= itemSpacing.x;
		labelRect.Max.x += itemSpacing.x;
		for (int i = 0; i < 4; ++i)
		{
			switch (i)
			{
				// left half-plane
			case 0: ImGui::PushClipRect(ImVec2(-FLT_MAX, -FLT_MAX), ImVec2(labelRect.Min.x, FLT_MAX), true); break;
				// right half-plane
			case 1: ImGui::PushClipRect(ImVec2(labelRect.Max.x, -FLT_MAX), ImVec2(FLT_MAX, FLT_MAX), true); break;
				// top
			case 2: ImGui::PushClipRect(ImVec2(labelRect.Min.x, -FLT_MAX), ImVec2(labelRect.Max.x, labelRect.Min.y), true); break;
				// bottom
			case 3: ImGui::PushClipRect(ImVec2(labelRect.Min.x, labelRect.Max.y), ImVec2(labelRect.Max.x, FLT_MAX), true); break;
			}

			ImGui::GetWindowDrawList()->AddRect(
				frameRect.Min, frameRect.Max,
				ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)),
				halfFrame.x);

			ImGui::PopClipRect();
		}

		ImGui::PopStyleVar(2);

#if IMGUI_VERSION_NUM >= 17301
		ImGui::GetCurrentWindow()->ContentRegionRect.Max.x += frameHeight * 0.5f;
		ImGui::GetCurrentWindow()->WorkRect.Max.x += frameHeight * 0.5f;
		ImGui::GetCurrentWindow()->InnerRect.Max.x += frameHeight * 0.5f;
#else
		ImGui::GetCurrentWindow()->ContentsRegionRect.Max.x += frameHeight * 0.5f;
#endif
		ImGui::GetCurrentWindow()->Size.x += frameHeight;

		ImGui::Dummy(ImVec2(0.0f, 0.0f));

		ImGui::EndGroup();
	}

	//////////////////////////////////////////////////////////////////////////
	template <int steps>
	void bezier_table(ImVec2 P[4], ImVec2 results[steps + 1])
	{
		static float C[(steps + 1) * 4], * K = 0;
		if (!K)
		{
			K = C;
			for (unsigned step = 0; step <= steps; ++step)
			{
				float t = (float)step / (float)steps;
				C[step * 4 + 0] = (1 - t) * (1 - t) * (1 - t);	// * P0
				C[step * 4 + 1] = 3 * (1 - t) * (1 - t) * t;	// * P1
				C[step * 4 + 2] = 3 * (1 - t) * t * t;			// * P2
				C[step * 4 + 3] = t * t * t;					// * P3
			}
		}
		for (unsigned step = 0; step <= steps; ++step)
		{
			ImVec2 point = {
				K[step * 4 + 0] * P[0].x + K[step * 4 + 1] * P[1].x + K[step * 4 + 2] * P[2].x + K[step * 4 + 3] * P[3].x,
				K[step * 4 + 0] * P[0].y + K[step * 4 + 1] * P[1].y + K[step * 4 + 2] * P[2].y + K[step * 4 + 3] * P[3].y
			};
			results[step] = point;
		}
	}

	float BezierValue(float dt01, float P[4])
	{
		enum { STEPS = 256 };
		ImVec2 Q[4] = { { 0, 0 }, { P[0], P[1] }, { P[2], P[3] }, { 1, 1 } };
		ImVec2 results[STEPS + 1];
		bezier_table<STEPS>(Q, results);
		return results[(int)((dt01 < 0 ? 0 : dt01 > 1 ? 1 : dt01) * STEPS)].y;
	}

	int Bezier(const char* label, float P[5])
	{
		// visuals
		enum { SMOOTHNESS = 64 }; // curve smoothness: the higher number of segments, the smoother curve
		enum { CURVE_WIDTH = 4 }; // main curved line width
		enum { LINE_WIDTH = 1 }; // handlers: small lines width
		enum { GRAB_RADIUS = 8 }; // handlers: circle radius
		enum { GRAB_BORDER = 2 }; // handlers: circle border width
		enum { AREA_CONSTRAINED = true }; // should grabbers be constrained to grid area?
		enum { AREA_WIDTH = 128 }; // area width in pixels. 0 for adaptive size (will use max avail width)

		// curve presets
		static struct { const char* name; float points[4]; } presets[] = {
			{ "Linear", 0.000f, 0.000f, 1.000f, 1.000f },

			{ "In Sine", 0.470f, 0.000f, 0.745f, 0.715f },
			{ "In Quad", 0.550f, 0.085f, 0.680f, 0.530f },
			{ "In Cubic", 0.550f, 0.055f, 0.675f, 0.190f },
			{ "In Quart", 0.895f, 0.030f, 0.685f, 0.220f },
			{ "In Quint", 0.755f, 0.050f, 0.855f, 0.060f },
			{ "In Expo", 0.950f, 0.050f, 0.795f, 0.035f },
			{ "In Circ", 0.600f, 0.040f, 0.980f, 0.335f },
			{ "In Back", 0.600f, -0.28f, 0.735f, 0.045f },

			{ "Out Sine", 0.390f, 0.575f, 0.565f, 1.000f },
			{ "Out Quad", 0.250f, 0.460f, 0.450f, 0.940f },
			{ "Out Cubic", 0.215f, 0.610f, 0.355f, 1.000f },
			{ "Out Quart", 0.165f, 0.840f, 0.440f, 1.000f },
			{ "Out Quint", 0.230f, 1.000f, 0.320f, 1.000f },
			{ "Out Expo", 0.190f, 1.000f, 0.220f, 1.000f },
			{ "Out Circ", 0.075f, 0.820f, 0.165f, 1.000f },
			{ "Out Back", 0.175f, 0.885f, 0.320f, 1.275f },

			{ "InOut Sine", 0.445f, 0.050f, 0.550f, 0.950f },
			{ "InOut Quad", 0.455f, 0.030f, 0.515f, 0.955f },
			{ "InOut Cubic", 0.645f, 0.045f, 0.355f, 1.000f },
			{ "InOut Quart", 0.770f, 0.000f, 0.175f, 1.000f },
			{ "InOut Quint", 0.860f, 0.000f, 0.070f, 1.000f },
			{ "InOut Expo", 1.000f, 0.000f, 0.000f, 1.000f },
			{ "InOut Circ", 0.785f, 0.135f, 0.150f, 0.860f },
			{ "InOut Back", 0.680f, -0.55f, 0.265f, 1.550f },

			// easeInElastic: not a bezier
			// easeOutElastic: not a bezier
			// easeInOutElastic: not a bezier
			// easeInBounce: not a bezier
			// easeOutBounce: not a bezier
			// easeInOutBounce: not a bezier
		};

		// preset selector

		bool reload = 0;
		ImGui::PushID(label);
		if (ImGui::ArrowButton("##lt", ImGuiDir_Left))
		{ // ImGui::ArrowButton(ImGui::GetCurrentWindow()->GetID("##lt"), ImGuiDir_Left, ImVec2(0, 0), 0)
			if (--P[4] >= 0) reload = 1; else ++P[4];
		}
		ImGui::SameLine();

		if (ImGui::Button("Presets"))
		{
			ImGui::OpenPopup("!Presets");
		}
		if (ImGui::BeginPopup("!Presets"))
		{
			for (int i = 0; i < IM_ARRAYSIZE(presets); ++i)
			{
				if (i == 1 || i == 9 || i == 17) ImGui::Separator();
				if (ImGui::MenuItem(presets[i].name, NULL, P[4] == i))
				{
					P[4] = i;
					reload = 1;
				}
			}
			ImGui::EndPopup();
		}
		ImGui::SameLine();

		if (ImGui::ArrowButton("##rt", ImGuiDir_Right))
		{ // ImGui::ArrowButton(ImGui::GetCurrentWindow()->GetID("##rt"), ImGuiDir_Right, ImVec2(0, 0), 0)
			if (++P[4] < IM_ARRAYSIZE(presets)) reload = 1; else --P[4];
		}
		ImGui::SameLine();
		ImGui::PopID();

		if (reload)
		{
			memcpy(P, presets[(int)P[4]].points, sizeof(float) * 4);
		}

		// bezier widget

		const ImGuiStyle& Style = ImGui::GetStyle();
		const ImGuiIO& IO = ImGui::GetIO();
		ImDrawList* DrawList = ImGui::GetWindowDrawList();
		ImGuiWindow* Window = ImGui::GetCurrentWindow();
		if (Window->SkipItems)
			return false;

		// header and spacing
		int changed = ImGui::SliderFloat4(label, P, 0, 1, "%.3f", 1.0f);
		int hovered = ImGui::IsItemActive() || ImGui::IsItemHovered(); // IsItemDragged() ?
		ImGui::Dummy(ImVec2(0, 3));

		// prepare canvas
		const float avail = ImGui::GetContentRegionAvailWidth();
		const float dim = AREA_WIDTH > 0 ? AREA_WIDTH : avail;
		ImVec2 Canvas(dim, dim);

		ImRect bb(Window->DC.CursorPos, Window->DC.CursorPos + Canvas);
		ImGui::ItemSize(bb);
		if (!ImGui::ItemAdd(bb, NULL))
			return changed;

		const ImGuiID id = Window->GetID(label);
		hovered |= 0 != ImGui::ItemHoverable(ImRect(bb.Min, bb.Min + ImVec2(avail, dim)), id);

		ImGui::RenderFrame(bb.Min, bb.Max, ImGui::GetColorU32(ImGuiCol_FrameBg, 1), true, Style.FrameRounding);

		// background grid
		for (int i = 0; i <= Canvas.x; i += (Canvas.x / 4))
		{
			DrawList->AddLine(
				ImVec2(bb.Min.x + i, bb.Min.y),
				ImVec2(bb.Min.x + i, bb.Max.y),
				ImGui::GetColorU32(ImGuiCol_TextDisabled));
		}
		for (int i = 0; i <= Canvas.y; i += (Canvas.y / 4))
		{
			DrawList->AddLine(
				ImVec2(bb.Min.x, bb.Min.y + i),
				ImVec2(bb.Max.x, bb.Min.y + i),
				ImGui::GetColorU32(ImGuiCol_TextDisabled));
		}

		// eval curve
		ImVec2 Q[4] = { { 0, 0 }, { P[0], P[1] }, { P[2], P[3] }, { 1, 1 } };
		ImVec2 results[SMOOTHNESS + 1];
		bezier_table<SMOOTHNESS>(Q, results);

		// control points: 2 lines and 2 circles
		{
			// handle grabbers
			ImVec2 mouse = ImGui::GetIO().MousePos, pos[2];
			float distance[2];

			for (int i = 0; i < 2; ++i)
			{
				pos[i] = ImVec2(P[i * 2 + 0], 1 - P[i * 2 + 1]) * (bb.Max - bb.Min) + bb.Min;
				distance[i] = (pos[i].x - mouse.x) * (pos[i].x - mouse.x) + (pos[i].y - mouse.y) * (pos[i].y - mouse.y);
			}

			int selected = distance[0] < distance[1] ? 0 : 1;
			if (distance[selected] < (4 * GRAB_RADIUS * 4 * GRAB_RADIUS))
			{
				ImGui::SetTooltip("(%4.3f, %4.3f)", P[selected * 2 + 0], P[selected * 2 + 1]);

				if (/*hovered &&*/ (ImGui::IsMouseClicked(0) || ImGui::IsMouseDragging(0)))
				{
					float& px = (P[selected * 2 + 0] += ImGui::GetIO().MouseDelta.x / Canvas.x);
					float& py = (P[selected * 2 + 1] -= ImGui::GetIO().MouseDelta.y / Canvas.y);

					if constexpr (AREA_CONSTRAINED) {
						px = (px < 0 ? 0 : (px > 1 ? 1 : px));
						py = (py < 0 ? 0 : (py > 1 ? 1 : py));
					}

					changed = true;
				}
			}
		}

		// if (hovered || changed) DrawList->PushClipRectFullScreen();

		// draw curve
		{
			ImColor color(ImGui::GetStyle().Colors[ImGuiCol_PlotLines]);
			for (int i = 0; i < SMOOTHNESS; ++i) {
				ImVec2 p = { results[i + 0].x, 1 - results[i + 0].y };
				ImVec2 q = { results[i + 1].x, 1 - results[i + 1].y };
				ImVec2 r(p.x * (bb.Max.x - bb.Min.x) + bb.Min.x, p.y * (bb.Max.y - bb.Min.y) + bb.Min.y);
				ImVec2 s(q.x * (bb.Max.x - bb.Min.x) + bb.Min.x, q.y * (bb.Max.y - bb.Min.y) + bb.Min.y);
				DrawList->AddLine(r, s, color, CURVE_WIDTH);
			}
		}

		// draw preview (cycles every 1s)
		static clock_t epoch = clock();
		ImVec4 white(ImGui::GetStyle().Colors[ImGuiCol_Text]);
		for (int i = 0; i < 3; ++i)
		{
			double now = ((clock() - epoch) / (double)CLOCKS_PER_SEC);
			float delta = ((int)(now * 1000) % 1000) / 1000.f; delta += i / 3.f; if (delta > 1) delta -= 1;
			int idx = (int)(delta * SMOOTHNESS);
			float evalx = results[idx].x; // 
			float evaly = results[idx].y; // ImGui::BezierValue( delta, P );
			ImVec2 p0 = ImVec2(evalx, 1 - 0) * (bb.Max - bb.Min) + bb.Min;
			ImVec2 p1 = ImVec2(0, 1 - evaly) * (bb.Max - bb.Min) + bb.Min;
			ImVec2 p2 = ImVec2(evalx, 1 - evaly) * (bb.Max - bb.Min) + bb.Min;
			DrawList->AddCircleFilled(p0, GRAB_RADIUS / 2, ImColor(white));
			DrawList->AddCircleFilled(p1, GRAB_RADIUS / 2, ImColor(white));
			DrawList->AddCircleFilled(p2, GRAB_RADIUS / 2, ImColor(white));
		}

		// draw lines and grabbers
		float luma = ImGui::IsItemActive() || ImGui::IsItemHovered() ? 0.5f : 1.0f;
		ImVec4 pink(1.00f, 0.00f, 0.75f, luma), cyan(0.00f, 0.75f, 1.00f, luma);
		ImVec2 p1 = ImVec2(P[0], 1 - P[1]) * (bb.Max - bb.Min) + bb.Min;
		ImVec2 p2 = ImVec2(P[2], 1 - P[3]) * (bb.Max - bb.Min) + bb.Min;
		DrawList->AddLine(ImVec2(bb.Min.x, bb.Max.y), p1, ImColor(white), LINE_WIDTH);
		DrawList->AddLine(ImVec2(bb.Max.x, bb.Min.y), p2, ImColor(white), LINE_WIDTH);
		DrawList->AddCircleFilled(p1, GRAB_RADIUS, ImColor(white));
		DrawList->AddCircleFilled(p1, GRAB_RADIUS - GRAB_BORDER, ImColor(pink));
		DrawList->AddCircleFilled(p2, GRAB_RADIUS, ImColor(white));
		DrawList->AddCircleFilled(p2, GRAB_RADIUS - GRAB_BORDER, ImColor(cyan));

		// if (hovered || changed) DrawList->PopClipRect();

		return changed;
	}

	void ShowBezierDemo() {
		{ static float v[5] = { 0.950f, 0.050f, 0.795f, 0.035f }; Bezier("easeInExpo", v); }
	}

	//////////////////////////////////////////////////////////////////////////
	constexpr float NODE_SLOT_RADIUS = 4.0f;

	int CurveEditor(const char* label,
					float* values,
					int points_count,
					const ImVec2& editor_size,
					ImU32 flags,
					int* new_count)
	{
		enum class StorageValues : ImGuiID
		{
			FROM_X = 100,
			FROM_Y,
			WIDTH,
			HEIGHT,
			IS_PANNING,
			POINT_START_X,
			POINT_START_Y
		};

		const float HEIGHT = 100;
		static ImVec2 start_pan;

		ImGuiContext& g = *GImGui;
		const ImGuiStyle& style = g.Style;
		ImVec2 size = editor_size;
		size.x = size.x < 0 ? ImGui::CalcItemWidth() + (style.FramePadding.x * 2) : size.x;
		size.y = size.y < 0 ? HEIGHT : size.y;

		ImGuiWindow* parent_window = ImGui::GetCurrentWindow();
		ImGuiID id = parent_window->GetID(label);
		if (!ImGui::BeginChildFrame(id, size, ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse))
		{
			ImGui::EndChild();
			return -1;
		}

		int hovered_idx = -1;
		if (new_count)* new_count = points_count;

		ImGuiWindow* window = ImGui::GetCurrentWindow();
		if (window->SkipItems)
		{
			ImGui::EndChild();
			return -1;
		}

		ImVec2 points_min(FLT_MAX, FLT_MAX);
		ImVec2 points_max(-FLT_MAX, -FLT_MAX);
		for (int point_idx = 0; point_idx < points_count; ++point_idx)
		{
			ImVec2 point;
			if (flags & (int)CurveEditorFlags::NO_TANGENTS)
			{
				point = ((ImVec2*)values)[point_idx];
			}
			else
			{
				point = ((ImVec2*)values)[1 + point_idx * 3];
			}
			points_max = ImMax(points_max, point);
			points_min = ImMin(points_min, point);
		}
		points_max.y = ImMax(points_max.y, points_min.y + 0.0001f);

		float from_x = window->StateStorage.GetFloat((ImGuiID)StorageValues::FROM_X, points_min.x);
		float from_y = window->StateStorage.GetFloat((ImGuiID)StorageValues::FROM_Y, points_min.y);
		float width = window->StateStorage.GetFloat((ImGuiID)StorageValues::WIDTH, points_max.x - points_min.x);
		float height = window->StateStorage.GetFloat((ImGuiID)StorageValues::HEIGHT, points_max.y - points_min.y);
		window->StateStorage.SetFloat((ImGuiID)StorageValues::FROM_X, from_x);
		window->StateStorage.SetFloat((ImGuiID)StorageValues::FROM_Y, from_y);
		window->StateStorage.SetFloat((ImGuiID)StorageValues::WIDTH, width);
		window->StateStorage.SetFloat((ImGuiID)StorageValues::HEIGHT, height);

		ImVec2 beg_pos = ImGui::GetCursorScreenPos();

		const ImRect inner_bb = window->InnerRect;
		const ImRect frame_bb(inner_bb.Min - style.FramePadding, inner_bb.Max + style.FramePadding);

		auto transform = [&](const ImVec2& pos) -> ImVec2
		{
			float x = (pos.x - from_x) / width;
			float y = (pos.y - from_y) / height;

			return ImVec2(
				inner_bb.Min.x * (1 - x) + inner_bb.Max.x * x,
				inner_bb.Min.y * y + inner_bb.Max.y * (1 - y)
			);
		};

		auto invTransform = [&](const ImVec2& pos) -> ImVec2
		{
			float x = (pos.x - inner_bb.Min.x) / (inner_bb.Max.x - inner_bb.Min.x);
			float y = (inner_bb.Max.y - pos.y) / (inner_bb.Max.y - inner_bb.Min.y);

			return ImVec2(
				from_x + width * x,
				from_y + height * y
			);
		};

		if (flags & (int)CurveEditorFlags::SHOW_GRID)
		{
			int exp;
			frexp(width / 5, &exp);
			float step_x = (float)ldexp(1.0, exp);
			int cell_cols = int(width / step_x);

			float x = step_x * int(from_x / step_x);
			for (int i = -1; i < cell_cols + 2; ++i)
			{
				ImVec2 a = transform({ x + i * step_x, from_y });
				ImVec2 b = transform({ x + i * step_x, from_y + height });
				window->DrawList->AddLine(a, b, 0x55000000);
				char buf[64];
				if (exp > 0)
				{
					ImFormatString(buf, sizeof(buf), " %d", int(x + i * step_x));
				}
				else
				{
					ImFormatString(buf, sizeof(buf), " %f", x + i * step_x);
				}
				window->DrawList->AddText(b, 0x55000000, buf);
			}

			frexp(height / 5, &exp);
			float step_y = (float)ldexp(1.0, exp);
			int cell_rows = int(height / step_y);

			float y = step_y * int(from_y / step_y);
			for (int i = -1; i < cell_rows + 2; ++i)
			{
				ImVec2 a = transform({ from_x, y + i * step_y });
				ImVec2 b = transform({ from_x + width, y + i * step_y });
				window->DrawList->AddLine(a, b, 0x55000000);
				char buf[64];
				if (exp > 0)
				{
					ImFormatString(buf, sizeof(buf), " %d", int(y + i * step_y));
				}
				else
				{
					ImFormatString(buf, sizeof(buf), " %f", y + i * step_y);
				}
				window->DrawList->AddText(a, 0x55000000, buf);
			}
		}

		if (ImGui::GetIO().MouseWheel != 0 && ImGui::IsItemHovered())
		{
			float scale = powf(2, ImGui::GetIO().MouseWheel);
			width *= scale;
			height *= scale;
			window->StateStorage.SetFloat((ImGuiID)StorageValues::WIDTH, width);
			window->StateStorage.SetFloat((ImGuiID)StorageValues::HEIGHT, height);
		}
		if (ImGui::IsMouseReleased(1))
		{
			window->StateStorage.SetBool((ImGuiID)StorageValues::IS_PANNING, false);
		}
		if (window->StateStorage.GetBool((ImGuiID)StorageValues::IS_PANNING, false))
		{
			ImVec2 drag_offset = ImGui::GetMouseDragDelta(1);
			from_x = start_pan.x;
			from_y = start_pan.y;
			from_x -= drag_offset.x * width / (inner_bb.Max.x - inner_bb.Min.x);
			from_y += drag_offset.y * height / (inner_bb.Max.y - inner_bb.Min.y);
			window->StateStorage.SetFloat((ImGuiID)StorageValues::FROM_X, from_x);
			window->StateStorage.SetFloat((ImGuiID)StorageValues::FROM_Y, from_y);
		}
		else if (ImGui::IsMouseDragging(1) && ImGui::IsItemHovered())
		{
			window->StateStorage.SetBool((ImGuiID)StorageValues::IS_PANNING, true);
			start_pan.x = from_x;
			start_pan.y = from_y;
		}

		int changed_idx = -1;
		for (int point_idx = points_count - 2; point_idx >= 0; --point_idx)
		{
			ImVec2* points;
			if (flags & (int)CurveEditorFlags::NO_TANGENTS)
			{
				points = ((ImVec2*)values) + point_idx;
			}
			else
			{
				points = ((ImVec2*)values) + 1 + point_idx * 3;
			}

			ImVec2 p_prev = points[0];
			ImVec2 tangent_last;
			ImVec2 tangent;
			ImVec2 p;
			if (flags & (int)CurveEditorFlags::NO_TANGENTS)
			{
				p = points[1];
			}
			else
			{
				tangent_last = points[1];
				tangent = points[2];
				p = points[3];
			}

			auto handlePoint = [&](ImVec2& p, int idx) -> bool
			{
				static const float SIZE = 3;

				ImVec2 cursor_pos = ImGui::GetCursorScreenPos();
				ImVec2 pos = transform(p);

				ImGui::SetCursorScreenPos(pos - ImVec2(SIZE, SIZE));
				ImGui::PushID(idx);
				ImGui::InvisibleButton("", ImVec2(2 * NODE_SLOT_RADIUS, 2 * NODE_SLOT_RADIUS));

				ImU32 col = ImGui::IsItemActive() || ImGui::IsItemHovered() ? ImGui::GetColorU32(ImGuiCol_PlotLinesHovered) : ImGui::GetColorU32(ImGuiCol_PlotLines);

				window->DrawList->AddLine(pos + ImVec2(-SIZE, 0), pos + ImVec2(0, SIZE), col);
				window->DrawList->AddLine(pos + ImVec2(SIZE, 0), pos + ImVec2(0, SIZE), col);
				window->DrawList->AddLine(pos + ImVec2(SIZE, 0), pos + ImVec2(0, -SIZE), col);
				window->DrawList->AddLine(pos + ImVec2(-SIZE, 0), pos + ImVec2(0, -SIZE), col);

				if (ImGui::IsItemHovered()) hovered_idx = point_idx + idx;

				bool changed = false;
				if (ImGui::IsItemActive() && ImGui::IsMouseClicked(0))
				{
					window->StateStorage.SetFloat((ImGuiID)StorageValues::POINT_START_X, pos.x);
					window->StateStorage.SetFloat((ImGuiID)StorageValues::POINT_START_Y, pos.y);
				}

				if (ImGui::IsItemHovered() || ImGui::IsItemActive() && ImGui::IsMouseDragging(0))
				{
					char tmp[64];
					ImFormatString(tmp, sizeof(tmp), "%0.2f, %0.2f", p.x, p.y);
					window->DrawList->AddText({ pos.x, pos.y - ImGui::GetTextLineHeight() }, 0xff000000, tmp);
				}

				if (ImGui::IsItemActive() && ImGui::IsMouseDragging(0))
				{
					pos.x = window->StateStorage.GetFloat((ImGuiID)StorageValues::POINT_START_X, pos.x);
					pos.y = window->StateStorage.GetFloat((ImGuiID)StorageValues::POINT_START_Y, pos.y);
					pos += ImGui::GetMouseDragDelta();
					ImVec2 v = invTransform(pos);

					p = v;
					changed = true;
				}
				ImGui::PopID();

				ImGui::SetCursorScreenPos(cursor_pos);
				return changed;
			};

			auto handleTangent = [&](ImVec2& t, const ImVec2& p, int idx) -> bool
			{
				static const float SIZE = 2;
				static const float LENGTH = 18;

				auto normalized = [](const ImVec2& v) -> ImVec2
				{
					float len = 1.0f / sqrtf(v.x * v.x + v.y * v.y);
					return ImVec2(v.x * len, v.y * len);
				};

				ImVec2 cursor_pos = ImGui::GetCursorScreenPos();
				ImVec2 pos = transform(p);
				ImVec2 tang = pos + normalized(ImVec2(t.x, -t.y)) * LENGTH;

				ImGui::SetCursorScreenPos(tang - ImVec2(SIZE, SIZE));
				ImGui::PushID(-idx);
				ImGui::InvisibleButton("", ImVec2(2 * NODE_SLOT_RADIUS, 2 * NODE_SLOT_RADIUS));

				window->DrawList->AddLine(pos, tang, ImGui::GetColorU32(ImGuiCol_PlotLines));

				ImU32 col = ImGui::IsItemHovered() ? ImGui::GetColorU32(ImGuiCol_PlotLinesHovered) : ImGui::GetColorU32(ImGuiCol_PlotLines);

				window->DrawList->AddLine(tang + ImVec2(-SIZE, SIZE), tang + ImVec2(SIZE, SIZE), col);
				window->DrawList->AddLine(tang + ImVec2(SIZE, SIZE), tang + ImVec2(SIZE, -SIZE), col);
				window->DrawList->AddLine(tang + ImVec2(SIZE, -SIZE), tang + ImVec2(-SIZE, -SIZE), col);
				window->DrawList->AddLine(tang + ImVec2(-SIZE, -SIZE), tang + ImVec2(-SIZE, SIZE), col);

				bool changed = false;
				if (ImGui::IsItemActive() && ImGui::IsMouseDragging(0))
				{
					tang = ImGui::GetIO().MousePos - pos;
					tang = normalized(tang);
					tang.y *= -1;

					t = tang;
					changed = true;
				}
				ImGui::PopID();

				ImGui::SetCursorScreenPos(cursor_pos);
				return changed;
			};

			ImGui::PushID(point_idx);
			if ((flags & (int)CurveEditorFlags::NO_TANGENTS) == 0)
			{
				window->DrawList->AddBezierCurve(
					transform(p_prev),
					transform(p_prev + tangent_last),
					transform(p + tangent),
					transform(p),
					ImGui::GetColorU32(ImGuiCol_PlotLines),
					1.0f,
					20);
				if (handleTangent(tangent_last, p_prev, 0))
				{
					points[1] = ImClamp(tangent_last, ImVec2(0, -1), ImVec2(1, 1));
					changed_idx = point_idx;
				}
				if (handleTangent(tangent, p, 1))
				{
					points[2] = ImClamp(tangent, ImVec2(-1, -1), ImVec2(0, 1));
					changed_idx = point_idx + 1;
				}
				if (handlePoint(p, 1))
				{
					if (p.x <= p_prev.x) p.x = p_prev.x + 0.001f;
					if (point_idx < points_count - 2 && p.x >= points[6].x)
					{
						p.x = points[6].x - 0.001f;
					}
					points[3] = p;
					changed_idx = point_idx + 1;
				}
			}
			else
			{
				window->DrawList->AddLine(transform(p_prev), transform(p), ImGui::GetColorU32(ImGuiCol_PlotLines), 1.0f);
				if (handlePoint(p, 1))
				{
					if (p.x <= p_prev.x)
						p.x = p_prev.x + 0.001f;

					if (point_idx < points_count - 2 && p.x >= points[2].x)
					{
						p.x = points[2].x - 0.001f;
					}
					points[1] = p;
					changed_idx = point_idx + 1;
				}
			}
			if (point_idx == 0)
			{
				if (handlePoint(p_prev, 0))
				{
					if (p.x <= p_prev.x)
						p_prev.x = p.x - 0.001f;

					points[0] = p_prev;
					changed_idx = point_idx;
				}
			}
			ImGui::PopID();
		}

		ImGui::SetCursorScreenPos(inner_bb.Min);
		ImGui::InvisibleButton("bg", inner_bb.Max - inner_bb.Min);

		if (ImGui::IsItemActive() && ImGui::IsMouseDoubleClicked(0) && new_count)
		{
			ImVec2 mp = ImGui::GetMousePos();
			ImVec2 new_p = invTransform(mp);
			ImVec2* points = (ImVec2*)values;

			if ((flags & (int)CurveEditorFlags::NO_TANGENTS) == 0)
			{
				points[points_count * 3 + 0] = ImVec2(-0.2f, 0);
				points[points_count * 3 + 1] = new_p;
				points[points_count * 3 + 2] = ImVec2(0.2f, 0);;
				++* new_count;

				auto compare = [](const void* a, const void* b) -> int
				{
					float fa = (((const ImVec2*)a) + 1)->x;
					float fb = (((const ImVec2*)b) + 1)->x;
					return fa < fb ? -1 : (fa > fb) ? 1 : 0;
				};

				qsort(values, points_count + 1, sizeof(ImVec2) * 3, compare);
			}
			else
			{
				points[points_count] = new_p;
				++* new_count;

				auto compare = [](const void* a, const void* b) -> int
				{
					float fa = ((const ImVec2*)a)->x;
					float fb = ((const ImVec2*)b)->x;
					return fa < fb ? -1 : (fa > fb) ? 1 : 0;
				};

				qsort(values, points_count + 1, sizeof(ImVec2), compare);
			}
		}

		if (hovered_idx >= 0 && ImGui::IsMouseDoubleClicked(0) && new_count && points_count > 2)
		{
			ImVec2* points = (ImVec2*)values;
			--* new_count;
			if ((flags & (int)CurveEditorFlags::NO_TANGENTS) == 0)
			{
				for (int j = hovered_idx * 3; j < points_count * 3 - 3; j += 3)
				{
					points[j + 0] = points[j + 3];
					points[j + 1] = points[j + 4];
					points[j + 2] = points[j + 5];
				}
			}
			else
			{
				for (int j = hovered_idx; j < points_count - 1; ++j)
				{
					points[j] = points[j + 1];
				}
			}
		}

		ImGui::EndChildFrame();
		ImGui::RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y), label);

		return changed_idx;
	}
}
